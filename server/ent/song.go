// Code generated by entc, DO NOT EDIT.

package ent

import (
	"encoding/json"
	"fmt"
	"strings"
	"time"

	"github.com/facebookincubator/ent/dialect/sql"
	"github.com/jeffsvajlenko/fortissimo/server/ent/song"
)

// Song is the model entity for the Song schema.
type Song struct {
	config `json:"-"`
	// ID of the ent.
	ID int64 `json:"id,omitempty"`
	// Path holds the value of the "path" field.
	Path string `json:"path,omitempty"`
	// Title holds the value of the "title" field.
	Title string `json:"title,omitempty"`
	// TitleSort holds the value of the "title_sort" field.
	TitleSort string `json:"title_sort,omitempty"`
	// Artists holds the value of the "artists" field.
	Artists []string `json:"artists,omitempty"`
	// FirstArtist holds the value of the "first_artist" field.
	FirstArtist string `json:"first_artist,omitempty"`
	// FirstArtistSort holds the value of the "first_artist_sort" field.
	FirstArtistSort string `json:"first_artist_sort,omitempty"`
	// FirstAlbumArtist holds the value of the "first_album_artist" field.
	FirstAlbumArtist string `json:"first_album_artist,omitempty"`
	// FirstAlbumArtistSort holds the value of the "first_album_artist_sort" field.
	FirstAlbumArtistSort string `json:"first_album_artist_sort,omitempty"`
	// AlbumArtist holds the value of the "album_artist" field.
	AlbumArtist string `json:"album_artist,omitempty"`
	// Album holds the value of the "album" field.
	Album string `json:"album,omitempty"`
	// Publisher holds the value of the "publisher" field.
	Publisher string `json:"publisher,omitempty"`
	// FirstComposer holds the value of the "first_composer" field.
	FirstComposer string `json:"first_composer,omitempty"`
	// Composers holds the value of the "composers" field.
	Composers string `json:"composers,omitempty"`
	// Conductor holds the value of the "conductor" field.
	Conductor string `json:"conductor,omitempty"`
	// Genre holds the value of the "genre" field.
	Genre string `json:"genre,omitempty"`
	// Grouping holds the value of the "grouping" field.
	Grouping string `json:"grouping,omitempty"`
	// Year holds the value of the "year" field.
	Year uint32 `json:"year,omitempty"`
	// TrackNumber holds the value of the "track_number" field.
	TrackNumber uint32 `json:"track_number,omitempty"`
	// OfTrackNumber holds the value of the "of_track_number" field.
	OfTrackNumber uint32 `json:"of_track_number,omitempty"`
	// DiskNumber holds the value of the "disk_number" field.
	DiskNumber uint32 `json:"disk_number,omitempty"`
	// OfDiskNumber holds the value of the "of_disk_number" field.
	OfDiskNumber uint32 `json:"of_disk_number,omitempty"`
	// Duration holds the value of the "duration" field.
	Duration uint32 `json:"duration,omitempty"`
	// PlayCount holds the value of the "play_count" field.
	PlayCount uint32 `json:"play_count,omitempty"`
	// SkippedCount holds the value of the "skipped_count" field.
	SkippedCount uint32 `json:"skipped_count,omitempty"`
	// Comment holds the value of the "comment" field.
	Comment string `json:"comment,omitempty"`
	// BeatsPerMinute holds the value of the "beats_per_minute" field.
	BeatsPerMinute uint32 `json:"beats_per_minute,omitempty"`
	// Copyright holds the value of the "copyright" field.
	Copyright string `json:"copyright,omitempty"`
	// DateTagged holds the value of the "date_tagged" field.
	DateTagged time.Time `json:"date_tagged,omitempty"`
	// Description holds the value of the "description" field.
	Description string `json:"description,omitempty"`
	// FirstComposerSort holds the value of the "first_composer_sort" field.
	FirstComposerSort string `json:"first_composer_sort,omitempty"`
	// ArtistsSort holds the value of the "artists_sort" field.
	ArtistsSort string `json:"artists_sort,omitempty"`
	// Lyrics holds the value of the "lyrics" field.
	Lyrics string `json:"lyrics,omitempty"`
	// InitialKey holds the value of the "initial_key" field.
	InitialKey string `json:"initial_key,omitempty"`
	// Isrc holds the value of the "isrc" field.
	Isrc string `json:"isrc,omitempty"`
	// Subtitle holds the value of the "subtitle" field.
	Subtitle string `json:"subtitle,omitempty"`
	// MusicBrainzArtistID holds the value of the "music_brainz_artist_id" field.
	MusicBrainzArtistID string `json:"music_brainz_artist_id,omitempty"`
	// MusicBrainzDiscID holds the value of the "music_brainz_disc_id" field.
	MusicBrainzDiscID string `json:"music_brainz_disc_id,omitempty"`
	// MusicBrainzReleaseArtistID holds the value of the "music_brainz_release_artist_id" field.
	MusicBrainzReleaseArtistID string `json:"music_brainz_release_artist_id,omitempty"`
	// MusicBrainzReleaseCountry holds the value of the "music_brainz_release_country" field.
	MusicBrainzReleaseCountry string `json:"music_brainz_release_country,omitempty"`
	// MusicBrainzReleaseGroupID holds the value of the "music_brainz_release_group_id" field.
	MusicBrainzReleaseGroupID string `json:"music_brainz_release_group_id,omitempty"`
	// MusicBrainzReleaseID holds the value of the "music_brainz_release_id" field.
	MusicBrainzReleaseID string `json:"music_brainz_release_id,omitempty"`
	// MusicBrainzReleaseStatus holds the value of the "music_brainz_release_status" field.
	MusicBrainzReleaseStatus string `json:"music_brainz_release_status,omitempty"`
	// MusicBrainzReleaseType holds the value of the "music_brainz_release_type" field.
	MusicBrainzReleaseType string `json:"music_brainz_release_type,omitempty"`
	// MusicBrainzTrackID holds the value of the "music_brainz_track_id" field.
	MusicBrainzTrackID string `json:"music_brainz_track_id,omitempty"`
	// MusicIPID holds the value of the "music_ip_id" field.
	MusicIPID string `json:"music_ip_id,omitempty"`
	// RemixedBy holds the value of the "remixed_by" field.
	RemixedBy string `json:"remixed_by,omitempty"`
	// ReplayGainAlbumGain holds the value of the "replay_gain_album_gain" field.
	ReplayGainAlbumGain float64 `json:"replay_gain_album_gain,omitempty"`
	// ReplayGainAlbumPeak holds the value of the "replay_gain_album_peak" field.
	ReplayGainAlbumPeak float64 `json:"replay_gain_album_peak,omitempty"`
	// ReplayGainTrackGain holds the value of the "replay_gain_track_gain" field.
	ReplayGainTrackGain float64 `json:"replay_gain_track_gain,omitempty"`
	// ReplayGainTrackPeak holds the value of the "replay_gain_track_peak" field.
	ReplayGainTrackPeak float64 `json:"replay_gain_track_peak,omitempty"`
	// MimeType holds the value of the "mime_type" field.
	MimeType string `json:"mime_type,omitempty"`
	// Edges holds the relations/edges for other nodes in the graph.
	// The values are being populated by the SongQuery when eager-loading is set.
	Edges SongEdges `json:"edges"`
}

// SongEdges holds the relations/edges for other nodes in the graph.
type SongEdges struct {
	// Tags holds the value of the tags edge.
	Tags []*Tag
	// loadedTypes holds the information for reporting if a
	// type was loaded (or requested) in eager-loading or not.
	loadedTypes [1]bool
}

// TagsOrErr returns the Tags value or an error if the edge
// was not loaded in eager-loading.
func (e SongEdges) TagsOrErr() ([]*Tag, error) {
	if e.loadedTypes[0] {
		return e.Tags, nil
	}
	return nil, &NotLoadedError{edge: "tags"}
}

// scanValues returns the types for scanning values from sql.Rows.
func (*Song) scanValues() []interface{} {
	return []interface{}{
		&sql.NullInt64{},   // id
		&sql.NullString{},  // path
		&sql.NullString{},  // title
		&sql.NullString{},  // title_sort
		&[]byte{},          // artists
		&sql.NullString{},  // first_artist
		&sql.NullString{},  // first_artist_sort
		&sql.NullString{},  // first_album_artist
		&sql.NullString{},  // first_album_artist_sort
		&sql.NullString{},  // album_artist
		&sql.NullString{},  // album
		&sql.NullString{},  // publisher
		&sql.NullString{},  // first_composer
		&sql.NullString{},  // composers
		&sql.NullString{},  // conductor
		&sql.NullString{},  // genre
		&sql.NullString{},  // grouping
		&sql.NullInt64{},   // year
		&sql.NullInt64{},   // track_number
		&sql.NullInt64{},   // of_track_number
		&sql.NullInt64{},   // disk_number
		&sql.NullInt64{},   // of_disk_number
		&sql.NullInt64{},   // duration
		&sql.NullInt64{},   // play_count
		&sql.NullInt64{},   // skipped_count
		&sql.NullString{},  // comment
		&sql.NullInt64{},   // beats_per_minute
		&sql.NullString{},  // copyright
		&sql.NullTime{},    // date_tagged
		&sql.NullString{},  // description
		&sql.NullString{},  // first_composer_sort
		&sql.NullString{},  // artists_sort
		&sql.NullString{},  // lyrics
		&sql.NullString{},  // initial_key
		&sql.NullString{},  // isrc
		&sql.NullString{},  // subtitle
		&sql.NullString{},  // music_brainz_artist_id
		&sql.NullString{},  // music_brainz_disc_id
		&sql.NullString{},  // music_brainz_release_artist_id
		&sql.NullString{},  // music_brainz_release_country
		&sql.NullString{},  // music_brainz_release_group_id
		&sql.NullString{},  // music_brainz_release_id
		&sql.NullString{},  // music_brainz_release_status
		&sql.NullString{},  // music_brainz_release_type
		&sql.NullString{},  // music_brainz_track_id
		&sql.NullString{},  // music_ip_id
		&sql.NullString{},  // remixed_by
		&sql.NullFloat64{}, // replay_gain_album_gain
		&sql.NullFloat64{}, // replay_gain_album_peak
		&sql.NullFloat64{}, // replay_gain_track_gain
		&sql.NullFloat64{}, // replay_gain_track_peak
		&sql.NullString{},  // mime_type
	}
}

// assignValues assigns the values that were returned from sql.Rows (after scanning)
// to the Song fields.
func (s *Song) assignValues(values ...interface{}) error {
	if m, n := len(values), len(song.Columns); m < n {
		return fmt.Errorf("mismatch number of scan values: %d != %d", m, n)
	}
	value, ok := values[0].(*sql.NullInt64)
	if !ok {
		return fmt.Errorf("unexpected type %T for field id", value)
	}
	s.ID = int64(value.Int64)
	values = values[1:]
	if value, ok := values[0].(*sql.NullString); !ok {
		return fmt.Errorf("unexpected type %T for field path", values[0])
	} else if value.Valid {
		s.Path = value.String
	}
	if value, ok := values[1].(*sql.NullString); !ok {
		return fmt.Errorf("unexpected type %T for field title", values[1])
	} else if value.Valid {
		s.Title = value.String
	}
	if value, ok := values[2].(*sql.NullString); !ok {
		return fmt.Errorf("unexpected type %T for field title_sort", values[2])
	} else if value.Valid {
		s.TitleSort = value.String
	}

	if value, ok := values[3].(*[]byte); !ok {
		return fmt.Errorf("unexpected type %T for field artists", values[3])
	} else if value != nil && len(*value) > 0 {
		if err := json.Unmarshal(*value, &s.Artists); err != nil {
			return fmt.Errorf("unmarshal field artists: %v", err)
		}
	}
	if value, ok := values[4].(*sql.NullString); !ok {
		return fmt.Errorf("unexpected type %T for field first_artist", values[4])
	} else if value.Valid {
		s.FirstArtist = value.String
	}
	if value, ok := values[5].(*sql.NullString); !ok {
		return fmt.Errorf("unexpected type %T for field first_artist_sort", values[5])
	} else if value.Valid {
		s.FirstArtistSort = value.String
	}
	if value, ok := values[6].(*sql.NullString); !ok {
		return fmt.Errorf("unexpected type %T for field first_album_artist", values[6])
	} else if value.Valid {
		s.FirstAlbumArtist = value.String
	}
	if value, ok := values[7].(*sql.NullString); !ok {
		return fmt.Errorf("unexpected type %T for field first_album_artist_sort", values[7])
	} else if value.Valid {
		s.FirstAlbumArtistSort = value.String
	}
	if value, ok := values[8].(*sql.NullString); !ok {
		return fmt.Errorf("unexpected type %T for field album_artist", values[8])
	} else if value.Valid {
		s.AlbumArtist = value.String
	}
	if value, ok := values[9].(*sql.NullString); !ok {
		return fmt.Errorf("unexpected type %T for field album", values[9])
	} else if value.Valid {
		s.Album = value.String
	}
	if value, ok := values[10].(*sql.NullString); !ok {
		return fmt.Errorf("unexpected type %T for field publisher", values[10])
	} else if value.Valid {
		s.Publisher = value.String
	}
	if value, ok := values[11].(*sql.NullString); !ok {
		return fmt.Errorf("unexpected type %T for field first_composer", values[11])
	} else if value.Valid {
		s.FirstComposer = value.String
	}
	if value, ok := values[12].(*sql.NullString); !ok {
		return fmt.Errorf("unexpected type %T for field composers", values[12])
	} else if value.Valid {
		s.Composers = value.String
	}
	if value, ok := values[13].(*sql.NullString); !ok {
		return fmt.Errorf("unexpected type %T for field conductor", values[13])
	} else if value.Valid {
		s.Conductor = value.String
	}
	if value, ok := values[14].(*sql.NullString); !ok {
		return fmt.Errorf("unexpected type %T for field genre", values[14])
	} else if value.Valid {
		s.Genre = value.String
	}
	if value, ok := values[15].(*sql.NullString); !ok {
		return fmt.Errorf("unexpected type %T for field grouping", values[15])
	} else if value.Valid {
		s.Grouping = value.String
	}
	if value, ok := values[16].(*sql.NullInt64); !ok {
		return fmt.Errorf("unexpected type %T for field year", values[16])
	} else if value.Valid {
		s.Year = uint32(value.Int64)
	}
	if value, ok := values[17].(*sql.NullInt64); !ok {
		return fmt.Errorf("unexpected type %T for field track_number", values[17])
	} else if value.Valid {
		s.TrackNumber = uint32(value.Int64)
	}
	if value, ok := values[18].(*sql.NullInt64); !ok {
		return fmt.Errorf("unexpected type %T for field of_track_number", values[18])
	} else if value.Valid {
		s.OfTrackNumber = uint32(value.Int64)
	}
	if value, ok := values[19].(*sql.NullInt64); !ok {
		return fmt.Errorf("unexpected type %T for field disk_number", values[19])
	} else if value.Valid {
		s.DiskNumber = uint32(value.Int64)
	}
	if value, ok := values[20].(*sql.NullInt64); !ok {
		return fmt.Errorf("unexpected type %T for field of_disk_number", values[20])
	} else if value.Valid {
		s.OfDiskNumber = uint32(value.Int64)
	}
	if value, ok := values[21].(*sql.NullInt64); !ok {
		return fmt.Errorf("unexpected type %T for field duration", values[21])
	} else if value.Valid {
		s.Duration = uint32(value.Int64)
	}
	if value, ok := values[22].(*sql.NullInt64); !ok {
		return fmt.Errorf("unexpected type %T for field play_count", values[22])
	} else if value.Valid {
		s.PlayCount = uint32(value.Int64)
	}
	if value, ok := values[23].(*sql.NullInt64); !ok {
		return fmt.Errorf("unexpected type %T for field skipped_count", values[23])
	} else if value.Valid {
		s.SkippedCount = uint32(value.Int64)
	}
	if value, ok := values[24].(*sql.NullString); !ok {
		return fmt.Errorf("unexpected type %T for field comment", values[24])
	} else if value.Valid {
		s.Comment = value.String
	}
	if value, ok := values[25].(*sql.NullInt64); !ok {
		return fmt.Errorf("unexpected type %T for field beats_per_minute", values[25])
	} else if value.Valid {
		s.BeatsPerMinute = uint32(value.Int64)
	}
	if value, ok := values[26].(*sql.NullString); !ok {
		return fmt.Errorf("unexpected type %T for field copyright", values[26])
	} else if value.Valid {
		s.Copyright = value.String
	}
	if value, ok := values[27].(*sql.NullTime); !ok {
		return fmt.Errorf("unexpected type %T for field date_tagged", values[27])
	} else if value.Valid {
		s.DateTagged = value.Time
	}
	if value, ok := values[28].(*sql.NullString); !ok {
		return fmt.Errorf("unexpected type %T for field description", values[28])
	} else if value.Valid {
		s.Description = value.String
	}
	if value, ok := values[29].(*sql.NullString); !ok {
		return fmt.Errorf("unexpected type %T for field first_composer_sort", values[29])
	} else if value.Valid {
		s.FirstComposerSort = value.String
	}
	if value, ok := values[30].(*sql.NullString); !ok {
		return fmt.Errorf("unexpected type %T for field artists_sort", values[30])
	} else if value.Valid {
		s.ArtistsSort = value.String
	}
	if value, ok := values[31].(*sql.NullString); !ok {
		return fmt.Errorf("unexpected type %T for field lyrics", values[31])
	} else if value.Valid {
		s.Lyrics = value.String
	}
	if value, ok := values[32].(*sql.NullString); !ok {
		return fmt.Errorf("unexpected type %T for field initial_key", values[32])
	} else if value.Valid {
		s.InitialKey = value.String
	}
	if value, ok := values[33].(*sql.NullString); !ok {
		return fmt.Errorf("unexpected type %T for field isrc", values[33])
	} else if value.Valid {
		s.Isrc = value.String
	}
	if value, ok := values[34].(*sql.NullString); !ok {
		return fmt.Errorf("unexpected type %T for field subtitle", values[34])
	} else if value.Valid {
		s.Subtitle = value.String
	}
	if value, ok := values[35].(*sql.NullString); !ok {
		return fmt.Errorf("unexpected type %T for field music_brainz_artist_id", values[35])
	} else if value.Valid {
		s.MusicBrainzArtistID = value.String
	}
	if value, ok := values[36].(*sql.NullString); !ok {
		return fmt.Errorf("unexpected type %T for field music_brainz_disc_id", values[36])
	} else if value.Valid {
		s.MusicBrainzDiscID = value.String
	}
	if value, ok := values[37].(*sql.NullString); !ok {
		return fmt.Errorf("unexpected type %T for field music_brainz_release_artist_id", values[37])
	} else if value.Valid {
		s.MusicBrainzReleaseArtistID = value.String
	}
	if value, ok := values[38].(*sql.NullString); !ok {
		return fmt.Errorf("unexpected type %T for field music_brainz_release_country", values[38])
	} else if value.Valid {
		s.MusicBrainzReleaseCountry = value.String
	}
	if value, ok := values[39].(*sql.NullString); !ok {
		return fmt.Errorf("unexpected type %T for field music_brainz_release_group_id", values[39])
	} else if value.Valid {
		s.MusicBrainzReleaseGroupID = value.String
	}
	if value, ok := values[40].(*sql.NullString); !ok {
		return fmt.Errorf("unexpected type %T for field music_brainz_release_id", values[40])
	} else if value.Valid {
		s.MusicBrainzReleaseID = value.String
	}
	if value, ok := values[41].(*sql.NullString); !ok {
		return fmt.Errorf("unexpected type %T for field music_brainz_release_status", values[41])
	} else if value.Valid {
		s.MusicBrainzReleaseStatus = value.String
	}
	if value, ok := values[42].(*sql.NullString); !ok {
		return fmt.Errorf("unexpected type %T for field music_brainz_release_type", values[42])
	} else if value.Valid {
		s.MusicBrainzReleaseType = value.String
	}
	if value, ok := values[43].(*sql.NullString); !ok {
		return fmt.Errorf("unexpected type %T for field music_brainz_track_id", values[43])
	} else if value.Valid {
		s.MusicBrainzTrackID = value.String
	}
	if value, ok := values[44].(*sql.NullString); !ok {
		return fmt.Errorf("unexpected type %T for field music_ip_id", values[44])
	} else if value.Valid {
		s.MusicIPID = value.String
	}
	if value, ok := values[45].(*sql.NullString); !ok {
		return fmt.Errorf("unexpected type %T for field remixed_by", values[45])
	} else if value.Valid {
		s.RemixedBy = value.String
	}
	if value, ok := values[46].(*sql.NullFloat64); !ok {
		return fmt.Errorf("unexpected type %T for field replay_gain_album_gain", values[46])
	} else if value.Valid {
		s.ReplayGainAlbumGain = value.Float64
	}
	if value, ok := values[47].(*sql.NullFloat64); !ok {
		return fmt.Errorf("unexpected type %T for field replay_gain_album_peak", values[47])
	} else if value.Valid {
		s.ReplayGainAlbumPeak = value.Float64
	}
	if value, ok := values[48].(*sql.NullFloat64); !ok {
		return fmt.Errorf("unexpected type %T for field replay_gain_track_gain", values[48])
	} else if value.Valid {
		s.ReplayGainTrackGain = value.Float64
	}
	if value, ok := values[49].(*sql.NullFloat64); !ok {
		return fmt.Errorf("unexpected type %T for field replay_gain_track_peak", values[49])
	} else if value.Valid {
		s.ReplayGainTrackPeak = value.Float64
	}
	if value, ok := values[50].(*sql.NullString); !ok {
		return fmt.Errorf("unexpected type %T for field mime_type", values[50])
	} else if value.Valid {
		s.MimeType = value.String
	}
	return nil
}

// QueryTags queries the tags edge of the Song.
func (s *Song) QueryTags() *TagQuery {
	return (&SongClient{config: s.config}).QueryTags(s)
}

// Update returns a builder for updating this Song.
// Note that, you need to call Song.Unwrap() before calling this method, if this Song
// was returned from a transaction, and the transaction was committed or rolled back.
func (s *Song) Update() *SongUpdateOne {
	return (&SongClient{config: s.config}).UpdateOne(s)
}

// Unwrap unwraps the entity that was returned from a transaction after it was closed,
// so that all next queries will be executed through the driver which created the transaction.
func (s *Song) Unwrap() *Song {
	tx, ok := s.config.driver.(*txDriver)
	if !ok {
		panic("ent: Song is not a transactional entity")
	}
	s.config.driver = tx.drv
	return s
}

// String implements the fmt.Stringer.
func (s *Song) String() string {
	var builder strings.Builder
	builder.WriteString("Song(")
	builder.WriteString(fmt.Sprintf("id=%v", s.ID))
	builder.WriteString(", path=")
	builder.WriteString(s.Path)
	builder.WriteString(", title=")
	builder.WriteString(s.Title)
	builder.WriteString(", title_sort=")
	builder.WriteString(s.TitleSort)
	builder.WriteString(", artists=")
	builder.WriteString(fmt.Sprintf("%v", s.Artists))
	builder.WriteString(", first_artist=")
	builder.WriteString(s.FirstArtist)
	builder.WriteString(", first_artist_sort=")
	builder.WriteString(s.FirstArtistSort)
	builder.WriteString(", first_album_artist=")
	builder.WriteString(s.FirstAlbumArtist)
	builder.WriteString(", first_album_artist_sort=")
	builder.WriteString(s.FirstAlbumArtistSort)
	builder.WriteString(", album_artist=")
	builder.WriteString(s.AlbumArtist)
	builder.WriteString(", album=")
	builder.WriteString(s.Album)
	builder.WriteString(", publisher=")
	builder.WriteString(s.Publisher)
	builder.WriteString(", first_composer=")
	builder.WriteString(s.FirstComposer)
	builder.WriteString(", composers=")
	builder.WriteString(s.Composers)
	builder.WriteString(", conductor=")
	builder.WriteString(s.Conductor)
	builder.WriteString(", genre=")
	builder.WriteString(s.Genre)
	builder.WriteString(", grouping=")
	builder.WriteString(s.Grouping)
	builder.WriteString(", year=")
	builder.WriteString(fmt.Sprintf("%v", s.Year))
	builder.WriteString(", track_number=")
	builder.WriteString(fmt.Sprintf("%v", s.TrackNumber))
	builder.WriteString(", of_track_number=")
	builder.WriteString(fmt.Sprintf("%v", s.OfTrackNumber))
	builder.WriteString(", disk_number=")
	builder.WriteString(fmt.Sprintf("%v", s.DiskNumber))
	builder.WriteString(", of_disk_number=")
	builder.WriteString(fmt.Sprintf("%v", s.OfDiskNumber))
	builder.WriteString(", duration=")
	builder.WriteString(fmt.Sprintf("%v", s.Duration))
	builder.WriteString(", play_count=")
	builder.WriteString(fmt.Sprintf("%v", s.PlayCount))
	builder.WriteString(", skipped_count=")
	builder.WriteString(fmt.Sprintf("%v", s.SkippedCount))
	builder.WriteString(", comment=")
	builder.WriteString(s.Comment)
	builder.WriteString(", beats_per_minute=")
	builder.WriteString(fmt.Sprintf("%v", s.BeatsPerMinute))
	builder.WriteString(", copyright=")
	builder.WriteString(s.Copyright)
	builder.WriteString(", date_tagged=")
	builder.WriteString(s.DateTagged.Format(time.ANSIC))
	builder.WriteString(", description=")
	builder.WriteString(s.Description)
	builder.WriteString(", first_composer_sort=")
	builder.WriteString(s.FirstComposerSort)
	builder.WriteString(", artists_sort=")
	builder.WriteString(s.ArtistsSort)
	builder.WriteString(", lyrics=")
	builder.WriteString(s.Lyrics)
	builder.WriteString(", initial_key=")
	builder.WriteString(s.InitialKey)
	builder.WriteString(", isrc=")
	builder.WriteString(s.Isrc)
	builder.WriteString(", subtitle=")
	builder.WriteString(s.Subtitle)
	builder.WriteString(", music_brainz_artist_id=")
	builder.WriteString(s.MusicBrainzArtistID)
	builder.WriteString(", music_brainz_disc_id=")
	builder.WriteString(s.MusicBrainzDiscID)
	builder.WriteString(", music_brainz_release_artist_id=")
	builder.WriteString(s.MusicBrainzReleaseArtistID)
	builder.WriteString(", music_brainz_release_country=")
	builder.WriteString(s.MusicBrainzReleaseCountry)
	builder.WriteString(", music_brainz_release_group_id=")
	builder.WriteString(s.MusicBrainzReleaseGroupID)
	builder.WriteString(", music_brainz_release_id=")
	builder.WriteString(s.MusicBrainzReleaseID)
	builder.WriteString(", music_brainz_release_status=")
	builder.WriteString(s.MusicBrainzReleaseStatus)
	builder.WriteString(", music_brainz_release_type=")
	builder.WriteString(s.MusicBrainzReleaseType)
	builder.WriteString(", music_brainz_track_id=")
	builder.WriteString(s.MusicBrainzTrackID)
	builder.WriteString(", music_ip_id=")
	builder.WriteString(s.MusicIPID)
	builder.WriteString(", remixed_by=")
	builder.WriteString(s.RemixedBy)
	builder.WriteString(", replay_gain_album_gain=")
	builder.WriteString(fmt.Sprintf("%v", s.ReplayGainAlbumGain))
	builder.WriteString(", replay_gain_album_peak=")
	builder.WriteString(fmt.Sprintf("%v", s.ReplayGainAlbumPeak))
	builder.WriteString(", replay_gain_track_gain=")
	builder.WriteString(fmt.Sprintf("%v", s.ReplayGainTrackGain))
	builder.WriteString(", replay_gain_track_peak=")
	builder.WriteString(fmt.Sprintf("%v", s.ReplayGainTrackPeak))
	builder.WriteString(", mime_type=")
	builder.WriteString(s.MimeType)
	builder.WriteByte(')')
	return builder.String()
}

// Songs is a parsable slice of Song.
type Songs []*Song

func (s Songs) config(cfg config) {
	for _i := range s {
		s[_i].config = cfg
	}
}
