// Code generated by entc, DO NOT EDIT.

package ent

import (
	"context"
	"fmt"
	"sync"
	"time"

	"github.com/jeffsvajlenko/fortissimo/server/ent/song"
	"github.com/jeffsvajlenko/fortissimo/server/ent/tag"

	"github.com/facebookincubator/ent"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeSong = "Song"
	TypeTag  = "Tag"
)

// SongMutation represents an operation that mutate the Songs
// nodes in the graph.
type SongMutation struct {
	config
	op                             Op
	typ                            string
	id                             *int64
	path                           *string
	title                          *string
	title_sort                     *string
	artists                        *[]string
	first_artist                   *string
	first_artist_sort              *string
	first_album_artist             *string
	first_album_artist_sort        *string
	album_artist                   *string
	album                          *string
	publisher                      *string
	first_composer                 *string
	composers                      *string
	conductor                      *string
	genre                          *string
	grouping                       *string
	year                           *uint
	addyear                        *uint
	track_number                   *uint
	addtrack_number                *uint
	of_track_number                *uint
	addof_track_number             *uint
	disk_number                    *uint
	adddisk_number                 *uint
	of_disk_number                 *uint
	addof_disk_number              *uint
	duration                       *int
	addduration                    *int
	play_count                     *uint
	addplay_count                  *uint
	skipped_count                  *uint
	addskipped_count               *uint
	comment                        *string
	beats_per_minute               *uint
	addbeats_per_minute            *uint
	copyright                      *string
	date_tagged                    *time.Time
	description                    *string
	first_composer_sort            *string
	artists_sort                   *string
	lyrics                         *string
	initial_key                    *string
	isrc                           *string
	subtitle                       *string
	music_brainz_artist_id         *string
	music_brainz_disc_id           *string
	music_brainz_release_artist_id *string
	music_brainz_release_country   *string
	music_brainz_release_group_id  *string
	music_brainz_release_id        *string
	music_brainz_release_status    *string
	music_brainz_release_type      *string
	music_brainz_track_id          *string
	music_ip_id                    *string
	remixed_by                     *string
	replay_gain_album_gain         *float64
	addreplay_gain_album_gain      *float64
	replay_gain_album_peak         *float64
	addreplay_gain_album_peak      *float64
	replay_gain_track_gain         *float64
	addreplay_gain_track_gain      *float64
	replay_gain_track_peak         *float64
	addreplay_gain_track_peak      *float64
	mime_type                      *string
	clearedFields                  map[string]struct{}
	tags                           map[int64]struct{}
	removedtags                    map[int64]struct{}
	done                           bool
	oldValue                       func(context.Context) (*Song, error)
}

var _ ent.Mutation = (*SongMutation)(nil)

// songOption allows to manage the mutation configuration using functional options.
type songOption func(*SongMutation)

// newSongMutation creates new mutation for $n.Name.
func newSongMutation(c config, op Op, opts ...songOption) *SongMutation {
	m := &SongMutation{
		config:        c,
		op:            op,
		typ:           TypeSong,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSongID sets the id field of the mutation.
func withSongID(id int64) songOption {
	return func(m *SongMutation) {
		var (
			err   error
			once  sync.Once
			value *Song
		)
		m.oldValue = func(ctx context.Context) (*Song, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Song.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSong sets the old Song of the mutation.
func withSong(node *Song) songOption {
	return func(m *SongMutation) {
		m.oldValue = func(context.Context) (*Song, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SongMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SongMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *SongMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetPath sets the path field.
func (m *SongMutation) SetPath(s string) {
	m.path = &s
}

// Path returns the path value in the mutation.
func (m *SongMutation) Path() (r string, exists bool) {
	v := m.path
	if v == nil {
		return
	}
	return *v, true
}

// OldPath returns the old path value of the Song.
// If the Song object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *SongMutation) OldPath(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldPath is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldPath requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPath: %w", err)
	}
	return oldValue.Path, nil
}

// ResetPath reset all changes of the "path" field.
func (m *SongMutation) ResetPath() {
	m.path = nil
}

// SetTitle sets the title field.
func (m *SongMutation) SetTitle(s string) {
	m.title = &s
}

// Title returns the title value in the mutation.
func (m *SongMutation) Title() (r string, exists bool) {
	v := m.title
	if v == nil {
		return
	}
	return *v, true
}

// OldTitle returns the old title value of the Song.
// If the Song object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *SongMutation) OldTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldTitle is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTitle: %w", err)
	}
	return oldValue.Title, nil
}

// ClearTitle clears the value of title.
func (m *SongMutation) ClearTitle() {
	m.title = nil
	m.clearedFields[song.FieldTitle] = struct{}{}
}

// TitleCleared returns if the field title was cleared in this mutation.
func (m *SongMutation) TitleCleared() bool {
	_, ok := m.clearedFields[song.FieldTitle]
	return ok
}

// ResetTitle reset all changes of the "title" field.
func (m *SongMutation) ResetTitle() {
	m.title = nil
	delete(m.clearedFields, song.FieldTitle)
}

// SetTitleSort sets the title_sort field.
func (m *SongMutation) SetTitleSort(s string) {
	m.title_sort = &s
}

// TitleSort returns the title_sort value in the mutation.
func (m *SongMutation) TitleSort() (r string, exists bool) {
	v := m.title_sort
	if v == nil {
		return
	}
	return *v, true
}

// OldTitleSort returns the old title_sort value of the Song.
// If the Song object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *SongMutation) OldTitleSort(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldTitleSort is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldTitleSort requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTitleSort: %w", err)
	}
	return oldValue.TitleSort, nil
}

// ClearTitleSort clears the value of title_sort.
func (m *SongMutation) ClearTitleSort() {
	m.title_sort = nil
	m.clearedFields[song.FieldTitleSort] = struct{}{}
}

// TitleSortCleared returns if the field title_sort was cleared in this mutation.
func (m *SongMutation) TitleSortCleared() bool {
	_, ok := m.clearedFields[song.FieldTitleSort]
	return ok
}

// ResetTitleSort reset all changes of the "title_sort" field.
func (m *SongMutation) ResetTitleSort() {
	m.title_sort = nil
	delete(m.clearedFields, song.FieldTitleSort)
}

// SetArtists sets the artists field.
func (m *SongMutation) SetArtists(s []string) {
	m.artists = &s
}

// Artists returns the artists value in the mutation.
func (m *SongMutation) Artists() (r []string, exists bool) {
	v := m.artists
	if v == nil {
		return
	}
	return *v, true
}

// OldArtists returns the old artists value of the Song.
// If the Song object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *SongMutation) OldArtists(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldArtists is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldArtists requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldArtists: %w", err)
	}
	return oldValue.Artists, nil
}

// ClearArtists clears the value of artists.
func (m *SongMutation) ClearArtists() {
	m.artists = nil
	m.clearedFields[song.FieldArtists] = struct{}{}
}

// ArtistsCleared returns if the field artists was cleared in this mutation.
func (m *SongMutation) ArtistsCleared() bool {
	_, ok := m.clearedFields[song.FieldArtists]
	return ok
}

// ResetArtists reset all changes of the "artists" field.
func (m *SongMutation) ResetArtists() {
	m.artists = nil
	delete(m.clearedFields, song.FieldArtists)
}

// SetFirstArtist sets the first_artist field.
func (m *SongMutation) SetFirstArtist(s string) {
	m.first_artist = &s
}

// FirstArtist returns the first_artist value in the mutation.
func (m *SongMutation) FirstArtist() (r string, exists bool) {
	v := m.first_artist
	if v == nil {
		return
	}
	return *v, true
}

// OldFirstArtist returns the old first_artist value of the Song.
// If the Song object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *SongMutation) OldFirstArtist(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldFirstArtist is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldFirstArtist requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFirstArtist: %w", err)
	}
	return oldValue.FirstArtist, nil
}

// ClearFirstArtist clears the value of first_artist.
func (m *SongMutation) ClearFirstArtist() {
	m.first_artist = nil
	m.clearedFields[song.FieldFirstArtist] = struct{}{}
}

// FirstArtistCleared returns if the field first_artist was cleared in this mutation.
func (m *SongMutation) FirstArtistCleared() bool {
	_, ok := m.clearedFields[song.FieldFirstArtist]
	return ok
}

// ResetFirstArtist reset all changes of the "first_artist" field.
func (m *SongMutation) ResetFirstArtist() {
	m.first_artist = nil
	delete(m.clearedFields, song.FieldFirstArtist)
}

// SetFirstArtistSort sets the first_artist_sort field.
func (m *SongMutation) SetFirstArtistSort(s string) {
	m.first_artist_sort = &s
}

// FirstArtistSort returns the first_artist_sort value in the mutation.
func (m *SongMutation) FirstArtistSort() (r string, exists bool) {
	v := m.first_artist_sort
	if v == nil {
		return
	}
	return *v, true
}

// OldFirstArtistSort returns the old first_artist_sort value of the Song.
// If the Song object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *SongMutation) OldFirstArtistSort(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldFirstArtistSort is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldFirstArtistSort requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFirstArtistSort: %w", err)
	}
	return oldValue.FirstArtistSort, nil
}

// ClearFirstArtistSort clears the value of first_artist_sort.
func (m *SongMutation) ClearFirstArtistSort() {
	m.first_artist_sort = nil
	m.clearedFields[song.FieldFirstArtistSort] = struct{}{}
}

// FirstArtistSortCleared returns if the field first_artist_sort was cleared in this mutation.
func (m *SongMutation) FirstArtistSortCleared() bool {
	_, ok := m.clearedFields[song.FieldFirstArtistSort]
	return ok
}

// ResetFirstArtistSort reset all changes of the "first_artist_sort" field.
func (m *SongMutation) ResetFirstArtistSort() {
	m.first_artist_sort = nil
	delete(m.clearedFields, song.FieldFirstArtistSort)
}

// SetFirstAlbumArtist sets the first_album_artist field.
func (m *SongMutation) SetFirstAlbumArtist(s string) {
	m.first_album_artist = &s
}

// FirstAlbumArtist returns the first_album_artist value in the mutation.
func (m *SongMutation) FirstAlbumArtist() (r string, exists bool) {
	v := m.first_album_artist
	if v == nil {
		return
	}
	return *v, true
}

// OldFirstAlbumArtist returns the old first_album_artist value of the Song.
// If the Song object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *SongMutation) OldFirstAlbumArtist(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldFirstAlbumArtist is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldFirstAlbumArtist requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFirstAlbumArtist: %w", err)
	}
	return oldValue.FirstAlbumArtist, nil
}

// ClearFirstAlbumArtist clears the value of first_album_artist.
func (m *SongMutation) ClearFirstAlbumArtist() {
	m.first_album_artist = nil
	m.clearedFields[song.FieldFirstAlbumArtist] = struct{}{}
}

// FirstAlbumArtistCleared returns if the field first_album_artist was cleared in this mutation.
func (m *SongMutation) FirstAlbumArtistCleared() bool {
	_, ok := m.clearedFields[song.FieldFirstAlbumArtist]
	return ok
}

// ResetFirstAlbumArtist reset all changes of the "first_album_artist" field.
func (m *SongMutation) ResetFirstAlbumArtist() {
	m.first_album_artist = nil
	delete(m.clearedFields, song.FieldFirstAlbumArtist)
}

// SetFirstAlbumArtistSort sets the first_album_artist_sort field.
func (m *SongMutation) SetFirstAlbumArtistSort(s string) {
	m.first_album_artist_sort = &s
}

// FirstAlbumArtistSort returns the first_album_artist_sort value in the mutation.
func (m *SongMutation) FirstAlbumArtistSort() (r string, exists bool) {
	v := m.first_album_artist_sort
	if v == nil {
		return
	}
	return *v, true
}

// OldFirstAlbumArtistSort returns the old first_album_artist_sort value of the Song.
// If the Song object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *SongMutation) OldFirstAlbumArtistSort(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldFirstAlbumArtistSort is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldFirstAlbumArtistSort requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFirstAlbumArtistSort: %w", err)
	}
	return oldValue.FirstAlbumArtistSort, nil
}

// ClearFirstAlbumArtistSort clears the value of first_album_artist_sort.
func (m *SongMutation) ClearFirstAlbumArtistSort() {
	m.first_album_artist_sort = nil
	m.clearedFields[song.FieldFirstAlbumArtistSort] = struct{}{}
}

// FirstAlbumArtistSortCleared returns if the field first_album_artist_sort was cleared in this mutation.
func (m *SongMutation) FirstAlbumArtistSortCleared() bool {
	_, ok := m.clearedFields[song.FieldFirstAlbumArtistSort]
	return ok
}

// ResetFirstAlbumArtistSort reset all changes of the "first_album_artist_sort" field.
func (m *SongMutation) ResetFirstAlbumArtistSort() {
	m.first_album_artist_sort = nil
	delete(m.clearedFields, song.FieldFirstAlbumArtistSort)
}

// SetAlbumArtist sets the album_artist field.
func (m *SongMutation) SetAlbumArtist(s string) {
	m.album_artist = &s
}

// AlbumArtist returns the album_artist value in the mutation.
func (m *SongMutation) AlbumArtist() (r string, exists bool) {
	v := m.album_artist
	if v == nil {
		return
	}
	return *v, true
}

// OldAlbumArtist returns the old album_artist value of the Song.
// If the Song object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *SongMutation) OldAlbumArtist(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldAlbumArtist is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldAlbumArtist requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAlbumArtist: %w", err)
	}
	return oldValue.AlbumArtist, nil
}

// ClearAlbumArtist clears the value of album_artist.
func (m *SongMutation) ClearAlbumArtist() {
	m.album_artist = nil
	m.clearedFields[song.FieldAlbumArtist] = struct{}{}
}

// AlbumArtistCleared returns if the field album_artist was cleared in this mutation.
func (m *SongMutation) AlbumArtistCleared() bool {
	_, ok := m.clearedFields[song.FieldAlbumArtist]
	return ok
}

// ResetAlbumArtist reset all changes of the "album_artist" field.
func (m *SongMutation) ResetAlbumArtist() {
	m.album_artist = nil
	delete(m.clearedFields, song.FieldAlbumArtist)
}

// SetAlbum sets the album field.
func (m *SongMutation) SetAlbum(s string) {
	m.album = &s
}

// Album returns the album value in the mutation.
func (m *SongMutation) Album() (r string, exists bool) {
	v := m.album
	if v == nil {
		return
	}
	return *v, true
}

// OldAlbum returns the old album value of the Song.
// If the Song object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *SongMutation) OldAlbum(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldAlbum is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldAlbum requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAlbum: %w", err)
	}
	return oldValue.Album, nil
}

// ClearAlbum clears the value of album.
func (m *SongMutation) ClearAlbum() {
	m.album = nil
	m.clearedFields[song.FieldAlbum] = struct{}{}
}

// AlbumCleared returns if the field album was cleared in this mutation.
func (m *SongMutation) AlbumCleared() bool {
	_, ok := m.clearedFields[song.FieldAlbum]
	return ok
}

// ResetAlbum reset all changes of the "album" field.
func (m *SongMutation) ResetAlbum() {
	m.album = nil
	delete(m.clearedFields, song.FieldAlbum)
}

// SetPublisher sets the publisher field.
func (m *SongMutation) SetPublisher(s string) {
	m.publisher = &s
}

// Publisher returns the publisher value in the mutation.
func (m *SongMutation) Publisher() (r string, exists bool) {
	v := m.publisher
	if v == nil {
		return
	}
	return *v, true
}

// OldPublisher returns the old publisher value of the Song.
// If the Song object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *SongMutation) OldPublisher(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldPublisher is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldPublisher requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPublisher: %w", err)
	}
	return oldValue.Publisher, nil
}

// ClearPublisher clears the value of publisher.
func (m *SongMutation) ClearPublisher() {
	m.publisher = nil
	m.clearedFields[song.FieldPublisher] = struct{}{}
}

// PublisherCleared returns if the field publisher was cleared in this mutation.
func (m *SongMutation) PublisherCleared() bool {
	_, ok := m.clearedFields[song.FieldPublisher]
	return ok
}

// ResetPublisher reset all changes of the "publisher" field.
func (m *SongMutation) ResetPublisher() {
	m.publisher = nil
	delete(m.clearedFields, song.FieldPublisher)
}

// SetFirstComposer sets the first_composer field.
func (m *SongMutation) SetFirstComposer(s string) {
	m.first_composer = &s
}

// FirstComposer returns the first_composer value in the mutation.
func (m *SongMutation) FirstComposer() (r string, exists bool) {
	v := m.first_composer
	if v == nil {
		return
	}
	return *v, true
}

// OldFirstComposer returns the old first_composer value of the Song.
// If the Song object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *SongMutation) OldFirstComposer(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldFirstComposer is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldFirstComposer requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFirstComposer: %w", err)
	}
	return oldValue.FirstComposer, nil
}

// ClearFirstComposer clears the value of first_composer.
func (m *SongMutation) ClearFirstComposer() {
	m.first_composer = nil
	m.clearedFields[song.FieldFirstComposer] = struct{}{}
}

// FirstComposerCleared returns if the field first_composer was cleared in this mutation.
func (m *SongMutation) FirstComposerCleared() bool {
	_, ok := m.clearedFields[song.FieldFirstComposer]
	return ok
}

// ResetFirstComposer reset all changes of the "first_composer" field.
func (m *SongMutation) ResetFirstComposer() {
	m.first_composer = nil
	delete(m.clearedFields, song.FieldFirstComposer)
}

// SetComposers sets the composers field.
func (m *SongMutation) SetComposers(s string) {
	m.composers = &s
}

// Composers returns the composers value in the mutation.
func (m *SongMutation) Composers() (r string, exists bool) {
	v := m.composers
	if v == nil {
		return
	}
	return *v, true
}

// OldComposers returns the old composers value of the Song.
// If the Song object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *SongMutation) OldComposers(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldComposers is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldComposers requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldComposers: %w", err)
	}
	return oldValue.Composers, nil
}

// ClearComposers clears the value of composers.
func (m *SongMutation) ClearComposers() {
	m.composers = nil
	m.clearedFields[song.FieldComposers] = struct{}{}
}

// ComposersCleared returns if the field composers was cleared in this mutation.
func (m *SongMutation) ComposersCleared() bool {
	_, ok := m.clearedFields[song.FieldComposers]
	return ok
}

// ResetComposers reset all changes of the "composers" field.
func (m *SongMutation) ResetComposers() {
	m.composers = nil
	delete(m.clearedFields, song.FieldComposers)
}

// SetConductor sets the conductor field.
func (m *SongMutation) SetConductor(s string) {
	m.conductor = &s
}

// Conductor returns the conductor value in the mutation.
func (m *SongMutation) Conductor() (r string, exists bool) {
	v := m.conductor
	if v == nil {
		return
	}
	return *v, true
}

// OldConductor returns the old conductor value of the Song.
// If the Song object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *SongMutation) OldConductor(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldConductor is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldConductor requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldConductor: %w", err)
	}
	return oldValue.Conductor, nil
}

// ClearConductor clears the value of conductor.
func (m *SongMutation) ClearConductor() {
	m.conductor = nil
	m.clearedFields[song.FieldConductor] = struct{}{}
}

// ConductorCleared returns if the field conductor was cleared in this mutation.
func (m *SongMutation) ConductorCleared() bool {
	_, ok := m.clearedFields[song.FieldConductor]
	return ok
}

// ResetConductor reset all changes of the "conductor" field.
func (m *SongMutation) ResetConductor() {
	m.conductor = nil
	delete(m.clearedFields, song.FieldConductor)
}

// SetGenre sets the genre field.
func (m *SongMutation) SetGenre(s string) {
	m.genre = &s
}

// Genre returns the genre value in the mutation.
func (m *SongMutation) Genre() (r string, exists bool) {
	v := m.genre
	if v == nil {
		return
	}
	return *v, true
}

// OldGenre returns the old genre value of the Song.
// If the Song object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *SongMutation) OldGenre(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldGenre is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldGenre requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGenre: %w", err)
	}
	return oldValue.Genre, nil
}

// ClearGenre clears the value of genre.
func (m *SongMutation) ClearGenre() {
	m.genre = nil
	m.clearedFields[song.FieldGenre] = struct{}{}
}

// GenreCleared returns if the field genre was cleared in this mutation.
func (m *SongMutation) GenreCleared() bool {
	_, ok := m.clearedFields[song.FieldGenre]
	return ok
}

// ResetGenre reset all changes of the "genre" field.
func (m *SongMutation) ResetGenre() {
	m.genre = nil
	delete(m.clearedFields, song.FieldGenre)
}

// SetGrouping sets the grouping field.
func (m *SongMutation) SetGrouping(s string) {
	m.grouping = &s
}

// Grouping returns the grouping value in the mutation.
func (m *SongMutation) Grouping() (r string, exists bool) {
	v := m.grouping
	if v == nil {
		return
	}
	return *v, true
}

// OldGrouping returns the old grouping value of the Song.
// If the Song object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *SongMutation) OldGrouping(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldGrouping is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldGrouping requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGrouping: %w", err)
	}
	return oldValue.Grouping, nil
}

// ClearGrouping clears the value of grouping.
func (m *SongMutation) ClearGrouping() {
	m.grouping = nil
	m.clearedFields[song.FieldGrouping] = struct{}{}
}

// GroupingCleared returns if the field grouping was cleared in this mutation.
func (m *SongMutation) GroupingCleared() bool {
	_, ok := m.clearedFields[song.FieldGrouping]
	return ok
}

// ResetGrouping reset all changes of the "grouping" field.
func (m *SongMutation) ResetGrouping() {
	m.grouping = nil
	delete(m.clearedFields, song.FieldGrouping)
}

// SetYear sets the year field.
func (m *SongMutation) SetYear(u uint) {
	m.year = &u
	m.addyear = nil
}

// Year returns the year value in the mutation.
func (m *SongMutation) Year() (r uint, exists bool) {
	v := m.year
	if v == nil {
		return
	}
	return *v, true
}

// OldYear returns the old year value of the Song.
// If the Song object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *SongMutation) OldYear(ctx context.Context) (v uint, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldYear is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldYear requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldYear: %w", err)
	}
	return oldValue.Year, nil
}

// AddYear adds u to year.
func (m *SongMutation) AddYear(u uint) {
	if m.addyear != nil {
		*m.addyear += u
	} else {
		m.addyear = &u
	}
}

// AddedYear returns the value that was added to the year field in this mutation.
func (m *SongMutation) AddedYear() (r uint, exists bool) {
	v := m.addyear
	if v == nil {
		return
	}
	return *v, true
}

// ClearYear clears the value of year.
func (m *SongMutation) ClearYear() {
	m.year = nil
	m.addyear = nil
	m.clearedFields[song.FieldYear] = struct{}{}
}

// YearCleared returns if the field year was cleared in this mutation.
func (m *SongMutation) YearCleared() bool {
	_, ok := m.clearedFields[song.FieldYear]
	return ok
}

// ResetYear reset all changes of the "year" field.
func (m *SongMutation) ResetYear() {
	m.year = nil
	m.addyear = nil
	delete(m.clearedFields, song.FieldYear)
}

// SetTrackNumber sets the track_number field.
func (m *SongMutation) SetTrackNumber(u uint) {
	m.track_number = &u
	m.addtrack_number = nil
}

// TrackNumber returns the track_number value in the mutation.
func (m *SongMutation) TrackNumber() (r uint, exists bool) {
	v := m.track_number
	if v == nil {
		return
	}
	return *v, true
}

// OldTrackNumber returns the old track_number value of the Song.
// If the Song object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *SongMutation) OldTrackNumber(ctx context.Context) (v uint, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldTrackNumber is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldTrackNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTrackNumber: %w", err)
	}
	return oldValue.TrackNumber, nil
}

// AddTrackNumber adds u to track_number.
func (m *SongMutation) AddTrackNumber(u uint) {
	if m.addtrack_number != nil {
		*m.addtrack_number += u
	} else {
		m.addtrack_number = &u
	}
}

// AddedTrackNumber returns the value that was added to the track_number field in this mutation.
func (m *SongMutation) AddedTrackNumber() (r uint, exists bool) {
	v := m.addtrack_number
	if v == nil {
		return
	}
	return *v, true
}

// ClearTrackNumber clears the value of track_number.
func (m *SongMutation) ClearTrackNumber() {
	m.track_number = nil
	m.addtrack_number = nil
	m.clearedFields[song.FieldTrackNumber] = struct{}{}
}

// TrackNumberCleared returns if the field track_number was cleared in this mutation.
func (m *SongMutation) TrackNumberCleared() bool {
	_, ok := m.clearedFields[song.FieldTrackNumber]
	return ok
}

// ResetTrackNumber reset all changes of the "track_number" field.
func (m *SongMutation) ResetTrackNumber() {
	m.track_number = nil
	m.addtrack_number = nil
	delete(m.clearedFields, song.FieldTrackNumber)
}

// SetOfTrackNumber sets the of_track_number field.
func (m *SongMutation) SetOfTrackNumber(u uint) {
	m.of_track_number = &u
	m.addof_track_number = nil
}

// OfTrackNumber returns the of_track_number value in the mutation.
func (m *SongMutation) OfTrackNumber() (r uint, exists bool) {
	v := m.of_track_number
	if v == nil {
		return
	}
	return *v, true
}

// OldOfTrackNumber returns the old of_track_number value of the Song.
// If the Song object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *SongMutation) OldOfTrackNumber(ctx context.Context) (v uint, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldOfTrackNumber is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldOfTrackNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOfTrackNumber: %w", err)
	}
	return oldValue.OfTrackNumber, nil
}

// AddOfTrackNumber adds u to of_track_number.
func (m *SongMutation) AddOfTrackNumber(u uint) {
	if m.addof_track_number != nil {
		*m.addof_track_number += u
	} else {
		m.addof_track_number = &u
	}
}

// AddedOfTrackNumber returns the value that was added to the of_track_number field in this mutation.
func (m *SongMutation) AddedOfTrackNumber() (r uint, exists bool) {
	v := m.addof_track_number
	if v == nil {
		return
	}
	return *v, true
}

// ClearOfTrackNumber clears the value of of_track_number.
func (m *SongMutation) ClearOfTrackNumber() {
	m.of_track_number = nil
	m.addof_track_number = nil
	m.clearedFields[song.FieldOfTrackNumber] = struct{}{}
}

// OfTrackNumberCleared returns if the field of_track_number was cleared in this mutation.
func (m *SongMutation) OfTrackNumberCleared() bool {
	_, ok := m.clearedFields[song.FieldOfTrackNumber]
	return ok
}

// ResetOfTrackNumber reset all changes of the "of_track_number" field.
func (m *SongMutation) ResetOfTrackNumber() {
	m.of_track_number = nil
	m.addof_track_number = nil
	delete(m.clearedFields, song.FieldOfTrackNumber)
}

// SetDiskNumber sets the disk_number field.
func (m *SongMutation) SetDiskNumber(u uint) {
	m.disk_number = &u
	m.adddisk_number = nil
}

// DiskNumber returns the disk_number value in the mutation.
func (m *SongMutation) DiskNumber() (r uint, exists bool) {
	v := m.disk_number
	if v == nil {
		return
	}
	return *v, true
}

// OldDiskNumber returns the old disk_number value of the Song.
// If the Song object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *SongMutation) OldDiskNumber(ctx context.Context) (v uint, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDiskNumber is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDiskNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDiskNumber: %w", err)
	}
	return oldValue.DiskNumber, nil
}

// AddDiskNumber adds u to disk_number.
func (m *SongMutation) AddDiskNumber(u uint) {
	if m.adddisk_number != nil {
		*m.adddisk_number += u
	} else {
		m.adddisk_number = &u
	}
}

// AddedDiskNumber returns the value that was added to the disk_number field in this mutation.
func (m *SongMutation) AddedDiskNumber() (r uint, exists bool) {
	v := m.adddisk_number
	if v == nil {
		return
	}
	return *v, true
}

// ClearDiskNumber clears the value of disk_number.
func (m *SongMutation) ClearDiskNumber() {
	m.disk_number = nil
	m.adddisk_number = nil
	m.clearedFields[song.FieldDiskNumber] = struct{}{}
}

// DiskNumberCleared returns if the field disk_number was cleared in this mutation.
func (m *SongMutation) DiskNumberCleared() bool {
	_, ok := m.clearedFields[song.FieldDiskNumber]
	return ok
}

// ResetDiskNumber reset all changes of the "disk_number" field.
func (m *SongMutation) ResetDiskNumber() {
	m.disk_number = nil
	m.adddisk_number = nil
	delete(m.clearedFields, song.FieldDiskNumber)
}

// SetOfDiskNumber sets the of_disk_number field.
func (m *SongMutation) SetOfDiskNumber(u uint) {
	m.of_disk_number = &u
	m.addof_disk_number = nil
}

// OfDiskNumber returns the of_disk_number value in the mutation.
func (m *SongMutation) OfDiskNumber() (r uint, exists bool) {
	v := m.of_disk_number
	if v == nil {
		return
	}
	return *v, true
}

// OldOfDiskNumber returns the old of_disk_number value of the Song.
// If the Song object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *SongMutation) OldOfDiskNumber(ctx context.Context) (v uint, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldOfDiskNumber is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldOfDiskNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOfDiskNumber: %w", err)
	}
	return oldValue.OfDiskNumber, nil
}

// AddOfDiskNumber adds u to of_disk_number.
func (m *SongMutation) AddOfDiskNumber(u uint) {
	if m.addof_disk_number != nil {
		*m.addof_disk_number += u
	} else {
		m.addof_disk_number = &u
	}
}

// AddedOfDiskNumber returns the value that was added to the of_disk_number field in this mutation.
func (m *SongMutation) AddedOfDiskNumber() (r uint, exists bool) {
	v := m.addof_disk_number
	if v == nil {
		return
	}
	return *v, true
}

// ClearOfDiskNumber clears the value of of_disk_number.
func (m *SongMutation) ClearOfDiskNumber() {
	m.of_disk_number = nil
	m.addof_disk_number = nil
	m.clearedFields[song.FieldOfDiskNumber] = struct{}{}
}

// OfDiskNumberCleared returns if the field of_disk_number was cleared in this mutation.
func (m *SongMutation) OfDiskNumberCleared() bool {
	_, ok := m.clearedFields[song.FieldOfDiskNumber]
	return ok
}

// ResetOfDiskNumber reset all changes of the "of_disk_number" field.
func (m *SongMutation) ResetOfDiskNumber() {
	m.of_disk_number = nil
	m.addof_disk_number = nil
	delete(m.clearedFields, song.FieldOfDiskNumber)
}

// SetDuration sets the duration field.
func (m *SongMutation) SetDuration(i int) {
	m.duration = &i
	m.addduration = nil
}

// Duration returns the duration value in the mutation.
func (m *SongMutation) Duration() (r int, exists bool) {
	v := m.duration
	if v == nil {
		return
	}
	return *v, true
}

// OldDuration returns the old duration value of the Song.
// If the Song object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *SongMutation) OldDuration(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDuration is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDuration requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDuration: %w", err)
	}
	return oldValue.Duration, nil
}

// AddDuration adds i to duration.
func (m *SongMutation) AddDuration(i int) {
	if m.addduration != nil {
		*m.addduration += i
	} else {
		m.addduration = &i
	}
}

// AddedDuration returns the value that was added to the duration field in this mutation.
func (m *SongMutation) AddedDuration() (r int, exists bool) {
	v := m.addduration
	if v == nil {
		return
	}
	return *v, true
}

// ClearDuration clears the value of duration.
func (m *SongMutation) ClearDuration() {
	m.duration = nil
	m.addduration = nil
	m.clearedFields[song.FieldDuration] = struct{}{}
}

// DurationCleared returns if the field duration was cleared in this mutation.
func (m *SongMutation) DurationCleared() bool {
	_, ok := m.clearedFields[song.FieldDuration]
	return ok
}

// ResetDuration reset all changes of the "duration" field.
func (m *SongMutation) ResetDuration() {
	m.duration = nil
	m.addduration = nil
	delete(m.clearedFields, song.FieldDuration)
}

// SetPlayCount sets the play_count field.
func (m *SongMutation) SetPlayCount(u uint) {
	m.play_count = &u
	m.addplay_count = nil
}

// PlayCount returns the play_count value in the mutation.
func (m *SongMutation) PlayCount() (r uint, exists bool) {
	v := m.play_count
	if v == nil {
		return
	}
	return *v, true
}

// OldPlayCount returns the old play_count value of the Song.
// If the Song object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *SongMutation) OldPlayCount(ctx context.Context) (v uint, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldPlayCount is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldPlayCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPlayCount: %w", err)
	}
	return oldValue.PlayCount, nil
}

// AddPlayCount adds u to play_count.
func (m *SongMutation) AddPlayCount(u uint) {
	if m.addplay_count != nil {
		*m.addplay_count += u
	} else {
		m.addplay_count = &u
	}
}

// AddedPlayCount returns the value that was added to the play_count field in this mutation.
func (m *SongMutation) AddedPlayCount() (r uint, exists bool) {
	v := m.addplay_count
	if v == nil {
		return
	}
	return *v, true
}

// ResetPlayCount reset all changes of the "play_count" field.
func (m *SongMutation) ResetPlayCount() {
	m.play_count = nil
	m.addplay_count = nil
}

// SetSkippedCount sets the skipped_count field.
func (m *SongMutation) SetSkippedCount(u uint) {
	m.skipped_count = &u
	m.addskipped_count = nil
}

// SkippedCount returns the skipped_count value in the mutation.
func (m *SongMutation) SkippedCount() (r uint, exists bool) {
	v := m.skipped_count
	if v == nil {
		return
	}
	return *v, true
}

// OldSkippedCount returns the old skipped_count value of the Song.
// If the Song object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *SongMutation) OldSkippedCount(ctx context.Context) (v uint, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldSkippedCount is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldSkippedCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSkippedCount: %w", err)
	}
	return oldValue.SkippedCount, nil
}

// AddSkippedCount adds u to skipped_count.
func (m *SongMutation) AddSkippedCount(u uint) {
	if m.addskipped_count != nil {
		*m.addskipped_count += u
	} else {
		m.addskipped_count = &u
	}
}

// AddedSkippedCount returns the value that was added to the skipped_count field in this mutation.
func (m *SongMutation) AddedSkippedCount() (r uint, exists bool) {
	v := m.addskipped_count
	if v == nil {
		return
	}
	return *v, true
}

// ResetSkippedCount reset all changes of the "skipped_count" field.
func (m *SongMutation) ResetSkippedCount() {
	m.skipped_count = nil
	m.addskipped_count = nil
}

// SetComment sets the comment field.
func (m *SongMutation) SetComment(s string) {
	m.comment = &s
}

// Comment returns the comment value in the mutation.
func (m *SongMutation) Comment() (r string, exists bool) {
	v := m.comment
	if v == nil {
		return
	}
	return *v, true
}

// OldComment returns the old comment value of the Song.
// If the Song object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *SongMutation) OldComment(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldComment is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldComment requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldComment: %w", err)
	}
	return oldValue.Comment, nil
}

// ClearComment clears the value of comment.
func (m *SongMutation) ClearComment() {
	m.comment = nil
	m.clearedFields[song.FieldComment] = struct{}{}
}

// CommentCleared returns if the field comment was cleared in this mutation.
func (m *SongMutation) CommentCleared() bool {
	_, ok := m.clearedFields[song.FieldComment]
	return ok
}

// ResetComment reset all changes of the "comment" field.
func (m *SongMutation) ResetComment() {
	m.comment = nil
	delete(m.clearedFields, song.FieldComment)
}

// SetBeatsPerMinute sets the beats_per_minute field.
func (m *SongMutation) SetBeatsPerMinute(u uint) {
	m.beats_per_minute = &u
	m.addbeats_per_minute = nil
}

// BeatsPerMinute returns the beats_per_minute value in the mutation.
func (m *SongMutation) BeatsPerMinute() (r uint, exists bool) {
	v := m.beats_per_minute
	if v == nil {
		return
	}
	return *v, true
}

// OldBeatsPerMinute returns the old beats_per_minute value of the Song.
// If the Song object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *SongMutation) OldBeatsPerMinute(ctx context.Context) (v uint, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldBeatsPerMinute is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldBeatsPerMinute requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBeatsPerMinute: %w", err)
	}
	return oldValue.BeatsPerMinute, nil
}

// AddBeatsPerMinute adds u to beats_per_minute.
func (m *SongMutation) AddBeatsPerMinute(u uint) {
	if m.addbeats_per_minute != nil {
		*m.addbeats_per_minute += u
	} else {
		m.addbeats_per_minute = &u
	}
}

// AddedBeatsPerMinute returns the value that was added to the beats_per_minute field in this mutation.
func (m *SongMutation) AddedBeatsPerMinute() (r uint, exists bool) {
	v := m.addbeats_per_minute
	if v == nil {
		return
	}
	return *v, true
}

// ClearBeatsPerMinute clears the value of beats_per_minute.
func (m *SongMutation) ClearBeatsPerMinute() {
	m.beats_per_minute = nil
	m.addbeats_per_minute = nil
	m.clearedFields[song.FieldBeatsPerMinute] = struct{}{}
}

// BeatsPerMinuteCleared returns if the field beats_per_minute was cleared in this mutation.
func (m *SongMutation) BeatsPerMinuteCleared() bool {
	_, ok := m.clearedFields[song.FieldBeatsPerMinute]
	return ok
}

// ResetBeatsPerMinute reset all changes of the "beats_per_minute" field.
func (m *SongMutation) ResetBeatsPerMinute() {
	m.beats_per_minute = nil
	m.addbeats_per_minute = nil
	delete(m.clearedFields, song.FieldBeatsPerMinute)
}

// SetCopyright sets the copyright field.
func (m *SongMutation) SetCopyright(s string) {
	m.copyright = &s
}

// Copyright returns the copyright value in the mutation.
func (m *SongMutation) Copyright() (r string, exists bool) {
	v := m.copyright
	if v == nil {
		return
	}
	return *v, true
}

// OldCopyright returns the old copyright value of the Song.
// If the Song object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *SongMutation) OldCopyright(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCopyright is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCopyright requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCopyright: %w", err)
	}
	return oldValue.Copyright, nil
}

// ClearCopyright clears the value of copyright.
func (m *SongMutation) ClearCopyright() {
	m.copyright = nil
	m.clearedFields[song.FieldCopyright] = struct{}{}
}

// CopyrightCleared returns if the field copyright was cleared in this mutation.
func (m *SongMutation) CopyrightCleared() bool {
	_, ok := m.clearedFields[song.FieldCopyright]
	return ok
}

// ResetCopyright reset all changes of the "copyright" field.
func (m *SongMutation) ResetCopyright() {
	m.copyright = nil
	delete(m.clearedFields, song.FieldCopyright)
}

// SetDateTagged sets the date_tagged field.
func (m *SongMutation) SetDateTagged(t time.Time) {
	m.date_tagged = &t
}

// DateTagged returns the date_tagged value in the mutation.
func (m *SongMutation) DateTagged() (r time.Time, exists bool) {
	v := m.date_tagged
	if v == nil {
		return
	}
	return *v, true
}

// OldDateTagged returns the old date_tagged value of the Song.
// If the Song object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *SongMutation) OldDateTagged(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDateTagged is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDateTagged requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDateTagged: %w", err)
	}
	return oldValue.DateTagged, nil
}

// ClearDateTagged clears the value of date_tagged.
func (m *SongMutation) ClearDateTagged() {
	m.date_tagged = nil
	m.clearedFields[song.FieldDateTagged] = struct{}{}
}

// DateTaggedCleared returns if the field date_tagged was cleared in this mutation.
func (m *SongMutation) DateTaggedCleared() bool {
	_, ok := m.clearedFields[song.FieldDateTagged]
	return ok
}

// ResetDateTagged reset all changes of the "date_tagged" field.
func (m *SongMutation) ResetDateTagged() {
	m.date_tagged = nil
	delete(m.clearedFields, song.FieldDateTagged)
}

// SetDescription sets the description field.
func (m *SongMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the description value in the mutation.
func (m *SongMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old description value of the Song.
// If the Song object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *SongMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDescription is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of description.
func (m *SongMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[song.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the field description was cleared in this mutation.
func (m *SongMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[song.FieldDescription]
	return ok
}

// ResetDescription reset all changes of the "description" field.
func (m *SongMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, song.FieldDescription)
}

// SetFirstComposerSort sets the first_composer_sort field.
func (m *SongMutation) SetFirstComposerSort(s string) {
	m.first_composer_sort = &s
}

// FirstComposerSort returns the first_composer_sort value in the mutation.
func (m *SongMutation) FirstComposerSort() (r string, exists bool) {
	v := m.first_composer_sort
	if v == nil {
		return
	}
	return *v, true
}

// OldFirstComposerSort returns the old first_composer_sort value of the Song.
// If the Song object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *SongMutation) OldFirstComposerSort(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldFirstComposerSort is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldFirstComposerSort requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFirstComposerSort: %w", err)
	}
	return oldValue.FirstComposerSort, nil
}

// ClearFirstComposerSort clears the value of first_composer_sort.
func (m *SongMutation) ClearFirstComposerSort() {
	m.first_composer_sort = nil
	m.clearedFields[song.FieldFirstComposerSort] = struct{}{}
}

// FirstComposerSortCleared returns if the field first_composer_sort was cleared in this mutation.
func (m *SongMutation) FirstComposerSortCleared() bool {
	_, ok := m.clearedFields[song.FieldFirstComposerSort]
	return ok
}

// ResetFirstComposerSort reset all changes of the "first_composer_sort" field.
func (m *SongMutation) ResetFirstComposerSort() {
	m.first_composer_sort = nil
	delete(m.clearedFields, song.FieldFirstComposerSort)
}

// SetArtistsSort sets the artists_sort field.
func (m *SongMutation) SetArtistsSort(s string) {
	m.artists_sort = &s
}

// ArtistsSort returns the artists_sort value in the mutation.
func (m *SongMutation) ArtistsSort() (r string, exists bool) {
	v := m.artists_sort
	if v == nil {
		return
	}
	return *v, true
}

// OldArtistsSort returns the old artists_sort value of the Song.
// If the Song object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *SongMutation) OldArtistsSort(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldArtistsSort is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldArtistsSort requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldArtistsSort: %w", err)
	}
	return oldValue.ArtistsSort, nil
}

// ClearArtistsSort clears the value of artists_sort.
func (m *SongMutation) ClearArtistsSort() {
	m.artists_sort = nil
	m.clearedFields[song.FieldArtistsSort] = struct{}{}
}

// ArtistsSortCleared returns if the field artists_sort was cleared in this mutation.
func (m *SongMutation) ArtistsSortCleared() bool {
	_, ok := m.clearedFields[song.FieldArtistsSort]
	return ok
}

// ResetArtistsSort reset all changes of the "artists_sort" field.
func (m *SongMutation) ResetArtistsSort() {
	m.artists_sort = nil
	delete(m.clearedFields, song.FieldArtistsSort)
}

// SetLyrics sets the lyrics field.
func (m *SongMutation) SetLyrics(s string) {
	m.lyrics = &s
}

// Lyrics returns the lyrics value in the mutation.
func (m *SongMutation) Lyrics() (r string, exists bool) {
	v := m.lyrics
	if v == nil {
		return
	}
	return *v, true
}

// OldLyrics returns the old lyrics value of the Song.
// If the Song object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *SongMutation) OldLyrics(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldLyrics is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldLyrics requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLyrics: %w", err)
	}
	return oldValue.Lyrics, nil
}

// ClearLyrics clears the value of lyrics.
func (m *SongMutation) ClearLyrics() {
	m.lyrics = nil
	m.clearedFields[song.FieldLyrics] = struct{}{}
}

// LyricsCleared returns if the field lyrics was cleared in this mutation.
func (m *SongMutation) LyricsCleared() bool {
	_, ok := m.clearedFields[song.FieldLyrics]
	return ok
}

// ResetLyrics reset all changes of the "lyrics" field.
func (m *SongMutation) ResetLyrics() {
	m.lyrics = nil
	delete(m.clearedFields, song.FieldLyrics)
}

// SetInitialKey sets the initial_key field.
func (m *SongMutation) SetInitialKey(s string) {
	m.initial_key = &s
}

// InitialKey returns the initial_key value in the mutation.
func (m *SongMutation) InitialKey() (r string, exists bool) {
	v := m.initial_key
	if v == nil {
		return
	}
	return *v, true
}

// OldInitialKey returns the old initial_key value of the Song.
// If the Song object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *SongMutation) OldInitialKey(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldInitialKey is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldInitialKey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInitialKey: %w", err)
	}
	return oldValue.InitialKey, nil
}

// ClearInitialKey clears the value of initial_key.
func (m *SongMutation) ClearInitialKey() {
	m.initial_key = nil
	m.clearedFields[song.FieldInitialKey] = struct{}{}
}

// InitialKeyCleared returns if the field initial_key was cleared in this mutation.
func (m *SongMutation) InitialKeyCleared() bool {
	_, ok := m.clearedFields[song.FieldInitialKey]
	return ok
}

// ResetInitialKey reset all changes of the "initial_key" field.
func (m *SongMutation) ResetInitialKey() {
	m.initial_key = nil
	delete(m.clearedFields, song.FieldInitialKey)
}

// SetIsrc sets the isrc field.
func (m *SongMutation) SetIsrc(s string) {
	m.isrc = &s
}

// Isrc returns the isrc value in the mutation.
func (m *SongMutation) Isrc() (r string, exists bool) {
	v := m.isrc
	if v == nil {
		return
	}
	return *v, true
}

// OldIsrc returns the old isrc value of the Song.
// If the Song object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *SongMutation) OldIsrc(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldIsrc is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldIsrc requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsrc: %w", err)
	}
	return oldValue.Isrc, nil
}

// ClearIsrc clears the value of isrc.
func (m *SongMutation) ClearIsrc() {
	m.isrc = nil
	m.clearedFields[song.FieldIsrc] = struct{}{}
}

// IsrcCleared returns if the field isrc was cleared in this mutation.
func (m *SongMutation) IsrcCleared() bool {
	_, ok := m.clearedFields[song.FieldIsrc]
	return ok
}

// ResetIsrc reset all changes of the "isrc" field.
func (m *SongMutation) ResetIsrc() {
	m.isrc = nil
	delete(m.clearedFields, song.FieldIsrc)
}

// SetSubtitle sets the subtitle field.
func (m *SongMutation) SetSubtitle(s string) {
	m.subtitle = &s
}

// Subtitle returns the subtitle value in the mutation.
func (m *SongMutation) Subtitle() (r string, exists bool) {
	v := m.subtitle
	if v == nil {
		return
	}
	return *v, true
}

// OldSubtitle returns the old subtitle value of the Song.
// If the Song object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *SongMutation) OldSubtitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldSubtitle is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldSubtitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSubtitle: %w", err)
	}
	return oldValue.Subtitle, nil
}

// ClearSubtitle clears the value of subtitle.
func (m *SongMutation) ClearSubtitle() {
	m.subtitle = nil
	m.clearedFields[song.FieldSubtitle] = struct{}{}
}

// SubtitleCleared returns if the field subtitle was cleared in this mutation.
func (m *SongMutation) SubtitleCleared() bool {
	_, ok := m.clearedFields[song.FieldSubtitle]
	return ok
}

// ResetSubtitle reset all changes of the "subtitle" field.
func (m *SongMutation) ResetSubtitle() {
	m.subtitle = nil
	delete(m.clearedFields, song.FieldSubtitle)
}

// SetMusicBrainzArtistID sets the music_brainz_artist_id field.
func (m *SongMutation) SetMusicBrainzArtistID(s string) {
	m.music_brainz_artist_id = &s
}

// MusicBrainzArtistID returns the music_brainz_artist_id value in the mutation.
func (m *SongMutation) MusicBrainzArtistID() (r string, exists bool) {
	v := m.music_brainz_artist_id
	if v == nil {
		return
	}
	return *v, true
}

// OldMusicBrainzArtistID returns the old music_brainz_artist_id value of the Song.
// If the Song object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *SongMutation) OldMusicBrainzArtistID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldMusicBrainzArtistID is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldMusicBrainzArtistID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMusicBrainzArtistID: %w", err)
	}
	return oldValue.MusicBrainzArtistID, nil
}

// ClearMusicBrainzArtistID clears the value of music_brainz_artist_id.
func (m *SongMutation) ClearMusicBrainzArtistID() {
	m.music_brainz_artist_id = nil
	m.clearedFields[song.FieldMusicBrainzArtistID] = struct{}{}
}

// MusicBrainzArtistIDCleared returns if the field music_brainz_artist_id was cleared in this mutation.
func (m *SongMutation) MusicBrainzArtistIDCleared() bool {
	_, ok := m.clearedFields[song.FieldMusicBrainzArtistID]
	return ok
}

// ResetMusicBrainzArtistID reset all changes of the "music_brainz_artist_id" field.
func (m *SongMutation) ResetMusicBrainzArtistID() {
	m.music_brainz_artist_id = nil
	delete(m.clearedFields, song.FieldMusicBrainzArtistID)
}

// SetMusicBrainzDiscID sets the music_brainz_disc_id field.
func (m *SongMutation) SetMusicBrainzDiscID(s string) {
	m.music_brainz_disc_id = &s
}

// MusicBrainzDiscID returns the music_brainz_disc_id value in the mutation.
func (m *SongMutation) MusicBrainzDiscID() (r string, exists bool) {
	v := m.music_brainz_disc_id
	if v == nil {
		return
	}
	return *v, true
}

// OldMusicBrainzDiscID returns the old music_brainz_disc_id value of the Song.
// If the Song object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *SongMutation) OldMusicBrainzDiscID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldMusicBrainzDiscID is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldMusicBrainzDiscID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMusicBrainzDiscID: %w", err)
	}
	return oldValue.MusicBrainzDiscID, nil
}

// ClearMusicBrainzDiscID clears the value of music_brainz_disc_id.
func (m *SongMutation) ClearMusicBrainzDiscID() {
	m.music_brainz_disc_id = nil
	m.clearedFields[song.FieldMusicBrainzDiscID] = struct{}{}
}

// MusicBrainzDiscIDCleared returns if the field music_brainz_disc_id was cleared in this mutation.
func (m *SongMutation) MusicBrainzDiscIDCleared() bool {
	_, ok := m.clearedFields[song.FieldMusicBrainzDiscID]
	return ok
}

// ResetMusicBrainzDiscID reset all changes of the "music_brainz_disc_id" field.
func (m *SongMutation) ResetMusicBrainzDiscID() {
	m.music_brainz_disc_id = nil
	delete(m.clearedFields, song.FieldMusicBrainzDiscID)
}

// SetMusicBrainzReleaseArtistID sets the music_brainz_release_artist_id field.
func (m *SongMutation) SetMusicBrainzReleaseArtistID(s string) {
	m.music_brainz_release_artist_id = &s
}

// MusicBrainzReleaseArtistID returns the music_brainz_release_artist_id value in the mutation.
func (m *SongMutation) MusicBrainzReleaseArtistID() (r string, exists bool) {
	v := m.music_brainz_release_artist_id
	if v == nil {
		return
	}
	return *v, true
}

// OldMusicBrainzReleaseArtistID returns the old music_brainz_release_artist_id value of the Song.
// If the Song object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *SongMutation) OldMusicBrainzReleaseArtistID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldMusicBrainzReleaseArtistID is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldMusicBrainzReleaseArtistID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMusicBrainzReleaseArtistID: %w", err)
	}
	return oldValue.MusicBrainzReleaseArtistID, nil
}

// ClearMusicBrainzReleaseArtistID clears the value of music_brainz_release_artist_id.
func (m *SongMutation) ClearMusicBrainzReleaseArtistID() {
	m.music_brainz_release_artist_id = nil
	m.clearedFields[song.FieldMusicBrainzReleaseArtistID] = struct{}{}
}

// MusicBrainzReleaseArtistIDCleared returns if the field music_brainz_release_artist_id was cleared in this mutation.
func (m *SongMutation) MusicBrainzReleaseArtistIDCleared() bool {
	_, ok := m.clearedFields[song.FieldMusicBrainzReleaseArtistID]
	return ok
}

// ResetMusicBrainzReleaseArtistID reset all changes of the "music_brainz_release_artist_id" field.
func (m *SongMutation) ResetMusicBrainzReleaseArtistID() {
	m.music_brainz_release_artist_id = nil
	delete(m.clearedFields, song.FieldMusicBrainzReleaseArtistID)
}

// SetMusicBrainzReleaseCountry sets the music_brainz_release_country field.
func (m *SongMutation) SetMusicBrainzReleaseCountry(s string) {
	m.music_brainz_release_country = &s
}

// MusicBrainzReleaseCountry returns the music_brainz_release_country value in the mutation.
func (m *SongMutation) MusicBrainzReleaseCountry() (r string, exists bool) {
	v := m.music_brainz_release_country
	if v == nil {
		return
	}
	return *v, true
}

// OldMusicBrainzReleaseCountry returns the old music_brainz_release_country value of the Song.
// If the Song object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *SongMutation) OldMusicBrainzReleaseCountry(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldMusicBrainzReleaseCountry is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldMusicBrainzReleaseCountry requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMusicBrainzReleaseCountry: %w", err)
	}
	return oldValue.MusicBrainzReleaseCountry, nil
}

// ClearMusicBrainzReleaseCountry clears the value of music_brainz_release_country.
func (m *SongMutation) ClearMusicBrainzReleaseCountry() {
	m.music_brainz_release_country = nil
	m.clearedFields[song.FieldMusicBrainzReleaseCountry] = struct{}{}
}

// MusicBrainzReleaseCountryCleared returns if the field music_brainz_release_country was cleared in this mutation.
func (m *SongMutation) MusicBrainzReleaseCountryCleared() bool {
	_, ok := m.clearedFields[song.FieldMusicBrainzReleaseCountry]
	return ok
}

// ResetMusicBrainzReleaseCountry reset all changes of the "music_brainz_release_country" field.
func (m *SongMutation) ResetMusicBrainzReleaseCountry() {
	m.music_brainz_release_country = nil
	delete(m.clearedFields, song.FieldMusicBrainzReleaseCountry)
}

// SetMusicBrainzReleaseGroupID sets the music_brainz_release_group_id field.
func (m *SongMutation) SetMusicBrainzReleaseGroupID(s string) {
	m.music_brainz_release_group_id = &s
}

// MusicBrainzReleaseGroupID returns the music_brainz_release_group_id value in the mutation.
func (m *SongMutation) MusicBrainzReleaseGroupID() (r string, exists bool) {
	v := m.music_brainz_release_group_id
	if v == nil {
		return
	}
	return *v, true
}

// OldMusicBrainzReleaseGroupID returns the old music_brainz_release_group_id value of the Song.
// If the Song object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *SongMutation) OldMusicBrainzReleaseGroupID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldMusicBrainzReleaseGroupID is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldMusicBrainzReleaseGroupID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMusicBrainzReleaseGroupID: %w", err)
	}
	return oldValue.MusicBrainzReleaseGroupID, nil
}

// ClearMusicBrainzReleaseGroupID clears the value of music_brainz_release_group_id.
func (m *SongMutation) ClearMusicBrainzReleaseGroupID() {
	m.music_brainz_release_group_id = nil
	m.clearedFields[song.FieldMusicBrainzReleaseGroupID] = struct{}{}
}

// MusicBrainzReleaseGroupIDCleared returns if the field music_brainz_release_group_id was cleared in this mutation.
func (m *SongMutation) MusicBrainzReleaseGroupIDCleared() bool {
	_, ok := m.clearedFields[song.FieldMusicBrainzReleaseGroupID]
	return ok
}

// ResetMusicBrainzReleaseGroupID reset all changes of the "music_brainz_release_group_id" field.
func (m *SongMutation) ResetMusicBrainzReleaseGroupID() {
	m.music_brainz_release_group_id = nil
	delete(m.clearedFields, song.FieldMusicBrainzReleaseGroupID)
}

// SetMusicBrainzReleaseID sets the music_brainz_release_id field.
func (m *SongMutation) SetMusicBrainzReleaseID(s string) {
	m.music_brainz_release_id = &s
}

// MusicBrainzReleaseID returns the music_brainz_release_id value in the mutation.
func (m *SongMutation) MusicBrainzReleaseID() (r string, exists bool) {
	v := m.music_brainz_release_id
	if v == nil {
		return
	}
	return *v, true
}

// OldMusicBrainzReleaseID returns the old music_brainz_release_id value of the Song.
// If the Song object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *SongMutation) OldMusicBrainzReleaseID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldMusicBrainzReleaseID is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldMusicBrainzReleaseID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMusicBrainzReleaseID: %w", err)
	}
	return oldValue.MusicBrainzReleaseID, nil
}

// ClearMusicBrainzReleaseID clears the value of music_brainz_release_id.
func (m *SongMutation) ClearMusicBrainzReleaseID() {
	m.music_brainz_release_id = nil
	m.clearedFields[song.FieldMusicBrainzReleaseID] = struct{}{}
}

// MusicBrainzReleaseIDCleared returns if the field music_brainz_release_id was cleared in this mutation.
func (m *SongMutation) MusicBrainzReleaseIDCleared() bool {
	_, ok := m.clearedFields[song.FieldMusicBrainzReleaseID]
	return ok
}

// ResetMusicBrainzReleaseID reset all changes of the "music_brainz_release_id" field.
func (m *SongMutation) ResetMusicBrainzReleaseID() {
	m.music_brainz_release_id = nil
	delete(m.clearedFields, song.FieldMusicBrainzReleaseID)
}

// SetMusicBrainzReleaseStatus sets the music_brainz_release_status field.
func (m *SongMutation) SetMusicBrainzReleaseStatus(s string) {
	m.music_brainz_release_status = &s
}

// MusicBrainzReleaseStatus returns the music_brainz_release_status value in the mutation.
func (m *SongMutation) MusicBrainzReleaseStatus() (r string, exists bool) {
	v := m.music_brainz_release_status
	if v == nil {
		return
	}
	return *v, true
}

// OldMusicBrainzReleaseStatus returns the old music_brainz_release_status value of the Song.
// If the Song object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *SongMutation) OldMusicBrainzReleaseStatus(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldMusicBrainzReleaseStatus is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldMusicBrainzReleaseStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMusicBrainzReleaseStatus: %w", err)
	}
	return oldValue.MusicBrainzReleaseStatus, nil
}

// ClearMusicBrainzReleaseStatus clears the value of music_brainz_release_status.
func (m *SongMutation) ClearMusicBrainzReleaseStatus() {
	m.music_brainz_release_status = nil
	m.clearedFields[song.FieldMusicBrainzReleaseStatus] = struct{}{}
}

// MusicBrainzReleaseStatusCleared returns if the field music_brainz_release_status was cleared in this mutation.
func (m *SongMutation) MusicBrainzReleaseStatusCleared() bool {
	_, ok := m.clearedFields[song.FieldMusicBrainzReleaseStatus]
	return ok
}

// ResetMusicBrainzReleaseStatus reset all changes of the "music_brainz_release_status" field.
func (m *SongMutation) ResetMusicBrainzReleaseStatus() {
	m.music_brainz_release_status = nil
	delete(m.clearedFields, song.FieldMusicBrainzReleaseStatus)
}

// SetMusicBrainzReleaseType sets the music_brainz_release_type field.
func (m *SongMutation) SetMusicBrainzReleaseType(s string) {
	m.music_brainz_release_type = &s
}

// MusicBrainzReleaseType returns the music_brainz_release_type value in the mutation.
func (m *SongMutation) MusicBrainzReleaseType() (r string, exists bool) {
	v := m.music_brainz_release_type
	if v == nil {
		return
	}
	return *v, true
}

// OldMusicBrainzReleaseType returns the old music_brainz_release_type value of the Song.
// If the Song object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *SongMutation) OldMusicBrainzReleaseType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldMusicBrainzReleaseType is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldMusicBrainzReleaseType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMusicBrainzReleaseType: %w", err)
	}
	return oldValue.MusicBrainzReleaseType, nil
}

// ClearMusicBrainzReleaseType clears the value of music_brainz_release_type.
func (m *SongMutation) ClearMusicBrainzReleaseType() {
	m.music_brainz_release_type = nil
	m.clearedFields[song.FieldMusicBrainzReleaseType] = struct{}{}
}

// MusicBrainzReleaseTypeCleared returns if the field music_brainz_release_type was cleared in this mutation.
func (m *SongMutation) MusicBrainzReleaseTypeCleared() bool {
	_, ok := m.clearedFields[song.FieldMusicBrainzReleaseType]
	return ok
}

// ResetMusicBrainzReleaseType reset all changes of the "music_brainz_release_type" field.
func (m *SongMutation) ResetMusicBrainzReleaseType() {
	m.music_brainz_release_type = nil
	delete(m.clearedFields, song.FieldMusicBrainzReleaseType)
}

// SetMusicBrainzTrackID sets the music_brainz_track_id field.
func (m *SongMutation) SetMusicBrainzTrackID(s string) {
	m.music_brainz_track_id = &s
}

// MusicBrainzTrackID returns the music_brainz_track_id value in the mutation.
func (m *SongMutation) MusicBrainzTrackID() (r string, exists bool) {
	v := m.music_brainz_track_id
	if v == nil {
		return
	}
	return *v, true
}

// OldMusicBrainzTrackID returns the old music_brainz_track_id value of the Song.
// If the Song object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *SongMutation) OldMusicBrainzTrackID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldMusicBrainzTrackID is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldMusicBrainzTrackID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMusicBrainzTrackID: %w", err)
	}
	return oldValue.MusicBrainzTrackID, nil
}

// ClearMusicBrainzTrackID clears the value of music_brainz_track_id.
func (m *SongMutation) ClearMusicBrainzTrackID() {
	m.music_brainz_track_id = nil
	m.clearedFields[song.FieldMusicBrainzTrackID] = struct{}{}
}

// MusicBrainzTrackIDCleared returns if the field music_brainz_track_id was cleared in this mutation.
func (m *SongMutation) MusicBrainzTrackIDCleared() bool {
	_, ok := m.clearedFields[song.FieldMusicBrainzTrackID]
	return ok
}

// ResetMusicBrainzTrackID reset all changes of the "music_brainz_track_id" field.
func (m *SongMutation) ResetMusicBrainzTrackID() {
	m.music_brainz_track_id = nil
	delete(m.clearedFields, song.FieldMusicBrainzTrackID)
}

// SetMusicIPID sets the music_ip_id field.
func (m *SongMutation) SetMusicIPID(s string) {
	m.music_ip_id = &s
}

// MusicIPID returns the music_ip_id value in the mutation.
func (m *SongMutation) MusicIPID() (r string, exists bool) {
	v := m.music_ip_id
	if v == nil {
		return
	}
	return *v, true
}

// OldMusicIPID returns the old music_ip_id value of the Song.
// If the Song object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *SongMutation) OldMusicIPID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldMusicIPID is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldMusicIPID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMusicIPID: %w", err)
	}
	return oldValue.MusicIPID, nil
}

// ClearMusicIPID clears the value of music_ip_id.
func (m *SongMutation) ClearMusicIPID() {
	m.music_ip_id = nil
	m.clearedFields[song.FieldMusicIPID] = struct{}{}
}

// MusicIPIDCleared returns if the field music_ip_id was cleared in this mutation.
func (m *SongMutation) MusicIPIDCleared() bool {
	_, ok := m.clearedFields[song.FieldMusicIPID]
	return ok
}

// ResetMusicIPID reset all changes of the "music_ip_id" field.
func (m *SongMutation) ResetMusicIPID() {
	m.music_ip_id = nil
	delete(m.clearedFields, song.FieldMusicIPID)
}

// SetRemixedBy sets the remixed_by field.
func (m *SongMutation) SetRemixedBy(s string) {
	m.remixed_by = &s
}

// RemixedBy returns the remixed_by value in the mutation.
func (m *SongMutation) RemixedBy() (r string, exists bool) {
	v := m.remixed_by
	if v == nil {
		return
	}
	return *v, true
}

// OldRemixedBy returns the old remixed_by value of the Song.
// If the Song object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *SongMutation) OldRemixedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldRemixedBy is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldRemixedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRemixedBy: %w", err)
	}
	return oldValue.RemixedBy, nil
}

// ClearRemixedBy clears the value of remixed_by.
func (m *SongMutation) ClearRemixedBy() {
	m.remixed_by = nil
	m.clearedFields[song.FieldRemixedBy] = struct{}{}
}

// RemixedByCleared returns if the field remixed_by was cleared in this mutation.
func (m *SongMutation) RemixedByCleared() bool {
	_, ok := m.clearedFields[song.FieldRemixedBy]
	return ok
}

// ResetRemixedBy reset all changes of the "remixed_by" field.
func (m *SongMutation) ResetRemixedBy() {
	m.remixed_by = nil
	delete(m.clearedFields, song.FieldRemixedBy)
}

// SetReplayGainAlbumGain sets the replay_gain_album_gain field.
func (m *SongMutation) SetReplayGainAlbumGain(f float64) {
	m.replay_gain_album_gain = &f
	m.addreplay_gain_album_gain = nil
}

// ReplayGainAlbumGain returns the replay_gain_album_gain value in the mutation.
func (m *SongMutation) ReplayGainAlbumGain() (r float64, exists bool) {
	v := m.replay_gain_album_gain
	if v == nil {
		return
	}
	return *v, true
}

// OldReplayGainAlbumGain returns the old replay_gain_album_gain value of the Song.
// If the Song object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *SongMutation) OldReplayGainAlbumGain(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldReplayGainAlbumGain is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldReplayGainAlbumGain requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReplayGainAlbumGain: %w", err)
	}
	return oldValue.ReplayGainAlbumGain, nil
}

// AddReplayGainAlbumGain adds f to replay_gain_album_gain.
func (m *SongMutation) AddReplayGainAlbumGain(f float64) {
	if m.addreplay_gain_album_gain != nil {
		*m.addreplay_gain_album_gain += f
	} else {
		m.addreplay_gain_album_gain = &f
	}
}

// AddedReplayGainAlbumGain returns the value that was added to the replay_gain_album_gain field in this mutation.
func (m *SongMutation) AddedReplayGainAlbumGain() (r float64, exists bool) {
	v := m.addreplay_gain_album_gain
	if v == nil {
		return
	}
	return *v, true
}

// ClearReplayGainAlbumGain clears the value of replay_gain_album_gain.
func (m *SongMutation) ClearReplayGainAlbumGain() {
	m.replay_gain_album_gain = nil
	m.addreplay_gain_album_gain = nil
	m.clearedFields[song.FieldReplayGainAlbumGain] = struct{}{}
}

// ReplayGainAlbumGainCleared returns if the field replay_gain_album_gain was cleared in this mutation.
func (m *SongMutation) ReplayGainAlbumGainCleared() bool {
	_, ok := m.clearedFields[song.FieldReplayGainAlbumGain]
	return ok
}

// ResetReplayGainAlbumGain reset all changes of the "replay_gain_album_gain" field.
func (m *SongMutation) ResetReplayGainAlbumGain() {
	m.replay_gain_album_gain = nil
	m.addreplay_gain_album_gain = nil
	delete(m.clearedFields, song.FieldReplayGainAlbumGain)
}

// SetReplayGainAlbumPeak sets the replay_gain_album_peak field.
func (m *SongMutation) SetReplayGainAlbumPeak(f float64) {
	m.replay_gain_album_peak = &f
	m.addreplay_gain_album_peak = nil
}

// ReplayGainAlbumPeak returns the replay_gain_album_peak value in the mutation.
func (m *SongMutation) ReplayGainAlbumPeak() (r float64, exists bool) {
	v := m.replay_gain_album_peak
	if v == nil {
		return
	}
	return *v, true
}

// OldReplayGainAlbumPeak returns the old replay_gain_album_peak value of the Song.
// If the Song object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *SongMutation) OldReplayGainAlbumPeak(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldReplayGainAlbumPeak is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldReplayGainAlbumPeak requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReplayGainAlbumPeak: %w", err)
	}
	return oldValue.ReplayGainAlbumPeak, nil
}

// AddReplayGainAlbumPeak adds f to replay_gain_album_peak.
func (m *SongMutation) AddReplayGainAlbumPeak(f float64) {
	if m.addreplay_gain_album_peak != nil {
		*m.addreplay_gain_album_peak += f
	} else {
		m.addreplay_gain_album_peak = &f
	}
}

// AddedReplayGainAlbumPeak returns the value that was added to the replay_gain_album_peak field in this mutation.
func (m *SongMutation) AddedReplayGainAlbumPeak() (r float64, exists bool) {
	v := m.addreplay_gain_album_peak
	if v == nil {
		return
	}
	return *v, true
}

// ClearReplayGainAlbumPeak clears the value of replay_gain_album_peak.
func (m *SongMutation) ClearReplayGainAlbumPeak() {
	m.replay_gain_album_peak = nil
	m.addreplay_gain_album_peak = nil
	m.clearedFields[song.FieldReplayGainAlbumPeak] = struct{}{}
}

// ReplayGainAlbumPeakCleared returns if the field replay_gain_album_peak was cleared in this mutation.
func (m *SongMutation) ReplayGainAlbumPeakCleared() bool {
	_, ok := m.clearedFields[song.FieldReplayGainAlbumPeak]
	return ok
}

// ResetReplayGainAlbumPeak reset all changes of the "replay_gain_album_peak" field.
func (m *SongMutation) ResetReplayGainAlbumPeak() {
	m.replay_gain_album_peak = nil
	m.addreplay_gain_album_peak = nil
	delete(m.clearedFields, song.FieldReplayGainAlbumPeak)
}

// SetReplayGainTrackGain sets the replay_gain_track_gain field.
func (m *SongMutation) SetReplayGainTrackGain(f float64) {
	m.replay_gain_track_gain = &f
	m.addreplay_gain_track_gain = nil
}

// ReplayGainTrackGain returns the replay_gain_track_gain value in the mutation.
func (m *SongMutation) ReplayGainTrackGain() (r float64, exists bool) {
	v := m.replay_gain_track_gain
	if v == nil {
		return
	}
	return *v, true
}

// OldReplayGainTrackGain returns the old replay_gain_track_gain value of the Song.
// If the Song object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *SongMutation) OldReplayGainTrackGain(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldReplayGainTrackGain is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldReplayGainTrackGain requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReplayGainTrackGain: %w", err)
	}
	return oldValue.ReplayGainTrackGain, nil
}

// AddReplayGainTrackGain adds f to replay_gain_track_gain.
func (m *SongMutation) AddReplayGainTrackGain(f float64) {
	if m.addreplay_gain_track_gain != nil {
		*m.addreplay_gain_track_gain += f
	} else {
		m.addreplay_gain_track_gain = &f
	}
}

// AddedReplayGainTrackGain returns the value that was added to the replay_gain_track_gain field in this mutation.
func (m *SongMutation) AddedReplayGainTrackGain() (r float64, exists bool) {
	v := m.addreplay_gain_track_gain
	if v == nil {
		return
	}
	return *v, true
}

// ClearReplayGainTrackGain clears the value of replay_gain_track_gain.
func (m *SongMutation) ClearReplayGainTrackGain() {
	m.replay_gain_track_gain = nil
	m.addreplay_gain_track_gain = nil
	m.clearedFields[song.FieldReplayGainTrackGain] = struct{}{}
}

// ReplayGainTrackGainCleared returns if the field replay_gain_track_gain was cleared in this mutation.
func (m *SongMutation) ReplayGainTrackGainCleared() bool {
	_, ok := m.clearedFields[song.FieldReplayGainTrackGain]
	return ok
}

// ResetReplayGainTrackGain reset all changes of the "replay_gain_track_gain" field.
func (m *SongMutation) ResetReplayGainTrackGain() {
	m.replay_gain_track_gain = nil
	m.addreplay_gain_track_gain = nil
	delete(m.clearedFields, song.FieldReplayGainTrackGain)
}

// SetReplayGainTrackPeak sets the replay_gain_track_peak field.
func (m *SongMutation) SetReplayGainTrackPeak(f float64) {
	m.replay_gain_track_peak = &f
	m.addreplay_gain_track_peak = nil
}

// ReplayGainTrackPeak returns the replay_gain_track_peak value in the mutation.
func (m *SongMutation) ReplayGainTrackPeak() (r float64, exists bool) {
	v := m.replay_gain_track_peak
	if v == nil {
		return
	}
	return *v, true
}

// OldReplayGainTrackPeak returns the old replay_gain_track_peak value of the Song.
// If the Song object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *SongMutation) OldReplayGainTrackPeak(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldReplayGainTrackPeak is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldReplayGainTrackPeak requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReplayGainTrackPeak: %w", err)
	}
	return oldValue.ReplayGainTrackPeak, nil
}

// AddReplayGainTrackPeak adds f to replay_gain_track_peak.
func (m *SongMutation) AddReplayGainTrackPeak(f float64) {
	if m.addreplay_gain_track_peak != nil {
		*m.addreplay_gain_track_peak += f
	} else {
		m.addreplay_gain_track_peak = &f
	}
}

// AddedReplayGainTrackPeak returns the value that was added to the replay_gain_track_peak field in this mutation.
func (m *SongMutation) AddedReplayGainTrackPeak() (r float64, exists bool) {
	v := m.addreplay_gain_track_peak
	if v == nil {
		return
	}
	return *v, true
}

// ClearReplayGainTrackPeak clears the value of replay_gain_track_peak.
func (m *SongMutation) ClearReplayGainTrackPeak() {
	m.replay_gain_track_peak = nil
	m.addreplay_gain_track_peak = nil
	m.clearedFields[song.FieldReplayGainTrackPeak] = struct{}{}
}

// ReplayGainTrackPeakCleared returns if the field replay_gain_track_peak was cleared in this mutation.
func (m *SongMutation) ReplayGainTrackPeakCleared() bool {
	_, ok := m.clearedFields[song.FieldReplayGainTrackPeak]
	return ok
}

// ResetReplayGainTrackPeak reset all changes of the "replay_gain_track_peak" field.
func (m *SongMutation) ResetReplayGainTrackPeak() {
	m.replay_gain_track_peak = nil
	m.addreplay_gain_track_peak = nil
	delete(m.clearedFields, song.FieldReplayGainTrackPeak)
}

// SetMimeType sets the mime_type field.
func (m *SongMutation) SetMimeType(s string) {
	m.mime_type = &s
}

// MimeType returns the mime_type value in the mutation.
func (m *SongMutation) MimeType() (r string, exists bool) {
	v := m.mime_type
	if v == nil {
		return
	}
	return *v, true
}

// OldMimeType returns the old mime_type value of the Song.
// If the Song object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *SongMutation) OldMimeType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldMimeType is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldMimeType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMimeType: %w", err)
	}
	return oldValue.MimeType, nil
}

// ClearMimeType clears the value of mime_type.
func (m *SongMutation) ClearMimeType() {
	m.mime_type = nil
	m.clearedFields[song.FieldMimeType] = struct{}{}
}

// MimeTypeCleared returns if the field mime_type was cleared in this mutation.
func (m *SongMutation) MimeTypeCleared() bool {
	_, ok := m.clearedFields[song.FieldMimeType]
	return ok
}

// ResetMimeType reset all changes of the "mime_type" field.
func (m *SongMutation) ResetMimeType() {
	m.mime_type = nil
	delete(m.clearedFields, song.FieldMimeType)
}

// AddTagIDs adds the tags edge to Tag by ids.
func (m *SongMutation) AddTagIDs(ids ...int64) {
	if m.tags == nil {
		m.tags = make(map[int64]struct{})
	}
	for i := range ids {
		m.tags[ids[i]] = struct{}{}
	}
}

// RemoveTagIDs removes the tags edge to Tag by ids.
func (m *SongMutation) RemoveTagIDs(ids ...int64) {
	if m.removedtags == nil {
		m.removedtags = make(map[int64]struct{})
	}
	for i := range ids {
		m.removedtags[ids[i]] = struct{}{}
	}
}

// RemovedTags returns the removed ids of tags.
func (m *SongMutation) RemovedTagsIDs() (ids []int64) {
	for id := range m.removedtags {
		ids = append(ids, id)
	}
	return
}

// TagsIDs returns the tags ids in the mutation.
func (m *SongMutation) TagsIDs() (ids []int64) {
	for id := range m.tags {
		ids = append(ids, id)
	}
	return
}

// ResetTags reset all changes of the "tags" edge.
func (m *SongMutation) ResetTags() {
	m.tags = nil
	m.removedtags = nil
}

// Op returns the operation name.
func (m *SongMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Song).
func (m *SongMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *SongMutation) Fields() []string {
	fields := make([]string, 0, 51)
	if m.path != nil {
		fields = append(fields, song.FieldPath)
	}
	if m.title != nil {
		fields = append(fields, song.FieldTitle)
	}
	if m.title_sort != nil {
		fields = append(fields, song.FieldTitleSort)
	}
	if m.artists != nil {
		fields = append(fields, song.FieldArtists)
	}
	if m.first_artist != nil {
		fields = append(fields, song.FieldFirstArtist)
	}
	if m.first_artist_sort != nil {
		fields = append(fields, song.FieldFirstArtistSort)
	}
	if m.first_album_artist != nil {
		fields = append(fields, song.FieldFirstAlbumArtist)
	}
	if m.first_album_artist_sort != nil {
		fields = append(fields, song.FieldFirstAlbumArtistSort)
	}
	if m.album_artist != nil {
		fields = append(fields, song.FieldAlbumArtist)
	}
	if m.album != nil {
		fields = append(fields, song.FieldAlbum)
	}
	if m.publisher != nil {
		fields = append(fields, song.FieldPublisher)
	}
	if m.first_composer != nil {
		fields = append(fields, song.FieldFirstComposer)
	}
	if m.composers != nil {
		fields = append(fields, song.FieldComposers)
	}
	if m.conductor != nil {
		fields = append(fields, song.FieldConductor)
	}
	if m.genre != nil {
		fields = append(fields, song.FieldGenre)
	}
	if m.grouping != nil {
		fields = append(fields, song.FieldGrouping)
	}
	if m.year != nil {
		fields = append(fields, song.FieldYear)
	}
	if m.track_number != nil {
		fields = append(fields, song.FieldTrackNumber)
	}
	if m.of_track_number != nil {
		fields = append(fields, song.FieldOfTrackNumber)
	}
	if m.disk_number != nil {
		fields = append(fields, song.FieldDiskNumber)
	}
	if m.of_disk_number != nil {
		fields = append(fields, song.FieldOfDiskNumber)
	}
	if m.duration != nil {
		fields = append(fields, song.FieldDuration)
	}
	if m.play_count != nil {
		fields = append(fields, song.FieldPlayCount)
	}
	if m.skipped_count != nil {
		fields = append(fields, song.FieldSkippedCount)
	}
	if m.comment != nil {
		fields = append(fields, song.FieldComment)
	}
	if m.beats_per_minute != nil {
		fields = append(fields, song.FieldBeatsPerMinute)
	}
	if m.copyright != nil {
		fields = append(fields, song.FieldCopyright)
	}
	if m.date_tagged != nil {
		fields = append(fields, song.FieldDateTagged)
	}
	if m.description != nil {
		fields = append(fields, song.FieldDescription)
	}
	if m.first_composer_sort != nil {
		fields = append(fields, song.FieldFirstComposerSort)
	}
	if m.artists_sort != nil {
		fields = append(fields, song.FieldArtistsSort)
	}
	if m.lyrics != nil {
		fields = append(fields, song.FieldLyrics)
	}
	if m.initial_key != nil {
		fields = append(fields, song.FieldInitialKey)
	}
	if m.isrc != nil {
		fields = append(fields, song.FieldIsrc)
	}
	if m.subtitle != nil {
		fields = append(fields, song.FieldSubtitle)
	}
	if m.music_brainz_artist_id != nil {
		fields = append(fields, song.FieldMusicBrainzArtistID)
	}
	if m.music_brainz_disc_id != nil {
		fields = append(fields, song.FieldMusicBrainzDiscID)
	}
	if m.music_brainz_release_artist_id != nil {
		fields = append(fields, song.FieldMusicBrainzReleaseArtistID)
	}
	if m.music_brainz_release_country != nil {
		fields = append(fields, song.FieldMusicBrainzReleaseCountry)
	}
	if m.music_brainz_release_group_id != nil {
		fields = append(fields, song.FieldMusicBrainzReleaseGroupID)
	}
	if m.music_brainz_release_id != nil {
		fields = append(fields, song.FieldMusicBrainzReleaseID)
	}
	if m.music_brainz_release_status != nil {
		fields = append(fields, song.FieldMusicBrainzReleaseStatus)
	}
	if m.music_brainz_release_type != nil {
		fields = append(fields, song.FieldMusicBrainzReleaseType)
	}
	if m.music_brainz_track_id != nil {
		fields = append(fields, song.FieldMusicBrainzTrackID)
	}
	if m.music_ip_id != nil {
		fields = append(fields, song.FieldMusicIPID)
	}
	if m.remixed_by != nil {
		fields = append(fields, song.FieldRemixedBy)
	}
	if m.replay_gain_album_gain != nil {
		fields = append(fields, song.FieldReplayGainAlbumGain)
	}
	if m.replay_gain_album_peak != nil {
		fields = append(fields, song.FieldReplayGainAlbumPeak)
	}
	if m.replay_gain_track_gain != nil {
		fields = append(fields, song.FieldReplayGainTrackGain)
	}
	if m.replay_gain_track_peak != nil {
		fields = append(fields, song.FieldReplayGainTrackPeak)
	}
	if m.mime_type != nil {
		fields = append(fields, song.FieldMimeType)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *SongMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case song.FieldPath:
		return m.Path()
	case song.FieldTitle:
		return m.Title()
	case song.FieldTitleSort:
		return m.TitleSort()
	case song.FieldArtists:
		return m.Artists()
	case song.FieldFirstArtist:
		return m.FirstArtist()
	case song.FieldFirstArtistSort:
		return m.FirstArtistSort()
	case song.FieldFirstAlbumArtist:
		return m.FirstAlbumArtist()
	case song.FieldFirstAlbumArtistSort:
		return m.FirstAlbumArtistSort()
	case song.FieldAlbumArtist:
		return m.AlbumArtist()
	case song.FieldAlbum:
		return m.Album()
	case song.FieldPublisher:
		return m.Publisher()
	case song.FieldFirstComposer:
		return m.FirstComposer()
	case song.FieldComposers:
		return m.Composers()
	case song.FieldConductor:
		return m.Conductor()
	case song.FieldGenre:
		return m.Genre()
	case song.FieldGrouping:
		return m.Grouping()
	case song.FieldYear:
		return m.Year()
	case song.FieldTrackNumber:
		return m.TrackNumber()
	case song.FieldOfTrackNumber:
		return m.OfTrackNumber()
	case song.FieldDiskNumber:
		return m.DiskNumber()
	case song.FieldOfDiskNumber:
		return m.OfDiskNumber()
	case song.FieldDuration:
		return m.Duration()
	case song.FieldPlayCount:
		return m.PlayCount()
	case song.FieldSkippedCount:
		return m.SkippedCount()
	case song.FieldComment:
		return m.Comment()
	case song.FieldBeatsPerMinute:
		return m.BeatsPerMinute()
	case song.FieldCopyright:
		return m.Copyright()
	case song.FieldDateTagged:
		return m.DateTagged()
	case song.FieldDescription:
		return m.Description()
	case song.FieldFirstComposerSort:
		return m.FirstComposerSort()
	case song.FieldArtistsSort:
		return m.ArtistsSort()
	case song.FieldLyrics:
		return m.Lyrics()
	case song.FieldInitialKey:
		return m.InitialKey()
	case song.FieldIsrc:
		return m.Isrc()
	case song.FieldSubtitle:
		return m.Subtitle()
	case song.FieldMusicBrainzArtistID:
		return m.MusicBrainzArtistID()
	case song.FieldMusicBrainzDiscID:
		return m.MusicBrainzDiscID()
	case song.FieldMusicBrainzReleaseArtistID:
		return m.MusicBrainzReleaseArtistID()
	case song.FieldMusicBrainzReleaseCountry:
		return m.MusicBrainzReleaseCountry()
	case song.FieldMusicBrainzReleaseGroupID:
		return m.MusicBrainzReleaseGroupID()
	case song.FieldMusicBrainzReleaseID:
		return m.MusicBrainzReleaseID()
	case song.FieldMusicBrainzReleaseStatus:
		return m.MusicBrainzReleaseStatus()
	case song.FieldMusicBrainzReleaseType:
		return m.MusicBrainzReleaseType()
	case song.FieldMusicBrainzTrackID:
		return m.MusicBrainzTrackID()
	case song.FieldMusicIPID:
		return m.MusicIPID()
	case song.FieldRemixedBy:
		return m.RemixedBy()
	case song.FieldReplayGainAlbumGain:
		return m.ReplayGainAlbumGain()
	case song.FieldReplayGainAlbumPeak:
		return m.ReplayGainAlbumPeak()
	case song.FieldReplayGainTrackGain:
		return m.ReplayGainTrackGain()
	case song.FieldReplayGainTrackPeak:
		return m.ReplayGainTrackPeak()
	case song.FieldMimeType:
		return m.MimeType()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *SongMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case song.FieldPath:
		return m.OldPath(ctx)
	case song.FieldTitle:
		return m.OldTitle(ctx)
	case song.FieldTitleSort:
		return m.OldTitleSort(ctx)
	case song.FieldArtists:
		return m.OldArtists(ctx)
	case song.FieldFirstArtist:
		return m.OldFirstArtist(ctx)
	case song.FieldFirstArtistSort:
		return m.OldFirstArtistSort(ctx)
	case song.FieldFirstAlbumArtist:
		return m.OldFirstAlbumArtist(ctx)
	case song.FieldFirstAlbumArtistSort:
		return m.OldFirstAlbumArtistSort(ctx)
	case song.FieldAlbumArtist:
		return m.OldAlbumArtist(ctx)
	case song.FieldAlbum:
		return m.OldAlbum(ctx)
	case song.FieldPublisher:
		return m.OldPublisher(ctx)
	case song.FieldFirstComposer:
		return m.OldFirstComposer(ctx)
	case song.FieldComposers:
		return m.OldComposers(ctx)
	case song.FieldConductor:
		return m.OldConductor(ctx)
	case song.FieldGenre:
		return m.OldGenre(ctx)
	case song.FieldGrouping:
		return m.OldGrouping(ctx)
	case song.FieldYear:
		return m.OldYear(ctx)
	case song.FieldTrackNumber:
		return m.OldTrackNumber(ctx)
	case song.FieldOfTrackNumber:
		return m.OldOfTrackNumber(ctx)
	case song.FieldDiskNumber:
		return m.OldDiskNumber(ctx)
	case song.FieldOfDiskNumber:
		return m.OldOfDiskNumber(ctx)
	case song.FieldDuration:
		return m.OldDuration(ctx)
	case song.FieldPlayCount:
		return m.OldPlayCount(ctx)
	case song.FieldSkippedCount:
		return m.OldSkippedCount(ctx)
	case song.FieldComment:
		return m.OldComment(ctx)
	case song.FieldBeatsPerMinute:
		return m.OldBeatsPerMinute(ctx)
	case song.FieldCopyright:
		return m.OldCopyright(ctx)
	case song.FieldDateTagged:
		return m.OldDateTagged(ctx)
	case song.FieldDescription:
		return m.OldDescription(ctx)
	case song.FieldFirstComposerSort:
		return m.OldFirstComposerSort(ctx)
	case song.FieldArtistsSort:
		return m.OldArtistsSort(ctx)
	case song.FieldLyrics:
		return m.OldLyrics(ctx)
	case song.FieldInitialKey:
		return m.OldInitialKey(ctx)
	case song.FieldIsrc:
		return m.OldIsrc(ctx)
	case song.FieldSubtitle:
		return m.OldSubtitle(ctx)
	case song.FieldMusicBrainzArtistID:
		return m.OldMusicBrainzArtistID(ctx)
	case song.FieldMusicBrainzDiscID:
		return m.OldMusicBrainzDiscID(ctx)
	case song.FieldMusicBrainzReleaseArtistID:
		return m.OldMusicBrainzReleaseArtistID(ctx)
	case song.FieldMusicBrainzReleaseCountry:
		return m.OldMusicBrainzReleaseCountry(ctx)
	case song.FieldMusicBrainzReleaseGroupID:
		return m.OldMusicBrainzReleaseGroupID(ctx)
	case song.FieldMusicBrainzReleaseID:
		return m.OldMusicBrainzReleaseID(ctx)
	case song.FieldMusicBrainzReleaseStatus:
		return m.OldMusicBrainzReleaseStatus(ctx)
	case song.FieldMusicBrainzReleaseType:
		return m.OldMusicBrainzReleaseType(ctx)
	case song.FieldMusicBrainzTrackID:
		return m.OldMusicBrainzTrackID(ctx)
	case song.FieldMusicIPID:
		return m.OldMusicIPID(ctx)
	case song.FieldRemixedBy:
		return m.OldRemixedBy(ctx)
	case song.FieldReplayGainAlbumGain:
		return m.OldReplayGainAlbumGain(ctx)
	case song.FieldReplayGainAlbumPeak:
		return m.OldReplayGainAlbumPeak(ctx)
	case song.FieldReplayGainTrackGain:
		return m.OldReplayGainTrackGain(ctx)
	case song.FieldReplayGainTrackPeak:
		return m.OldReplayGainTrackPeak(ctx)
	case song.FieldMimeType:
		return m.OldMimeType(ctx)
	}
	return nil, fmt.Errorf("unknown Song field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *SongMutation) SetField(name string, value ent.Value) error {
	switch name {
	case song.FieldPath:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPath(v)
		return nil
	case song.FieldTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTitle(v)
		return nil
	case song.FieldTitleSort:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTitleSort(v)
		return nil
	case song.FieldArtists:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetArtists(v)
		return nil
	case song.FieldFirstArtist:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFirstArtist(v)
		return nil
	case song.FieldFirstArtistSort:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFirstArtistSort(v)
		return nil
	case song.FieldFirstAlbumArtist:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFirstAlbumArtist(v)
		return nil
	case song.FieldFirstAlbumArtistSort:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFirstAlbumArtistSort(v)
		return nil
	case song.FieldAlbumArtist:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAlbumArtist(v)
		return nil
	case song.FieldAlbum:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAlbum(v)
		return nil
	case song.FieldPublisher:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPublisher(v)
		return nil
	case song.FieldFirstComposer:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFirstComposer(v)
		return nil
	case song.FieldComposers:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetComposers(v)
		return nil
	case song.FieldConductor:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetConductor(v)
		return nil
	case song.FieldGenre:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGenre(v)
		return nil
	case song.FieldGrouping:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGrouping(v)
		return nil
	case song.FieldYear:
		v, ok := value.(uint)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetYear(v)
		return nil
	case song.FieldTrackNumber:
		v, ok := value.(uint)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTrackNumber(v)
		return nil
	case song.FieldOfTrackNumber:
		v, ok := value.(uint)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOfTrackNumber(v)
		return nil
	case song.FieldDiskNumber:
		v, ok := value.(uint)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDiskNumber(v)
		return nil
	case song.FieldOfDiskNumber:
		v, ok := value.(uint)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOfDiskNumber(v)
		return nil
	case song.FieldDuration:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDuration(v)
		return nil
	case song.FieldPlayCount:
		v, ok := value.(uint)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPlayCount(v)
		return nil
	case song.FieldSkippedCount:
		v, ok := value.(uint)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSkippedCount(v)
		return nil
	case song.FieldComment:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetComment(v)
		return nil
	case song.FieldBeatsPerMinute:
		v, ok := value.(uint)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBeatsPerMinute(v)
		return nil
	case song.FieldCopyright:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCopyright(v)
		return nil
	case song.FieldDateTagged:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDateTagged(v)
		return nil
	case song.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case song.FieldFirstComposerSort:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFirstComposerSort(v)
		return nil
	case song.FieldArtistsSort:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetArtistsSort(v)
		return nil
	case song.FieldLyrics:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLyrics(v)
		return nil
	case song.FieldInitialKey:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInitialKey(v)
		return nil
	case song.FieldIsrc:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsrc(v)
		return nil
	case song.FieldSubtitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSubtitle(v)
		return nil
	case song.FieldMusicBrainzArtistID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMusicBrainzArtistID(v)
		return nil
	case song.FieldMusicBrainzDiscID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMusicBrainzDiscID(v)
		return nil
	case song.FieldMusicBrainzReleaseArtistID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMusicBrainzReleaseArtistID(v)
		return nil
	case song.FieldMusicBrainzReleaseCountry:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMusicBrainzReleaseCountry(v)
		return nil
	case song.FieldMusicBrainzReleaseGroupID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMusicBrainzReleaseGroupID(v)
		return nil
	case song.FieldMusicBrainzReleaseID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMusicBrainzReleaseID(v)
		return nil
	case song.FieldMusicBrainzReleaseStatus:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMusicBrainzReleaseStatus(v)
		return nil
	case song.FieldMusicBrainzReleaseType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMusicBrainzReleaseType(v)
		return nil
	case song.FieldMusicBrainzTrackID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMusicBrainzTrackID(v)
		return nil
	case song.FieldMusicIPID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMusicIPID(v)
		return nil
	case song.FieldRemixedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRemixedBy(v)
		return nil
	case song.FieldReplayGainAlbumGain:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReplayGainAlbumGain(v)
		return nil
	case song.FieldReplayGainAlbumPeak:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReplayGainAlbumPeak(v)
		return nil
	case song.FieldReplayGainTrackGain:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReplayGainTrackGain(v)
		return nil
	case song.FieldReplayGainTrackPeak:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReplayGainTrackPeak(v)
		return nil
	case song.FieldMimeType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMimeType(v)
		return nil
	}
	return fmt.Errorf("unknown Song field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *SongMutation) AddedFields() []string {
	var fields []string
	if m.addyear != nil {
		fields = append(fields, song.FieldYear)
	}
	if m.addtrack_number != nil {
		fields = append(fields, song.FieldTrackNumber)
	}
	if m.addof_track_number != nil {
		fields = append(fields, song.FieldOfTrackNumber)
	}
	if m.adddisk_number != nil {
		fields = append(fields, song.FieldDiskNumber)
	}
	if m.addof_disk_number != nil {
		fields = append(fields, song.FieldOfDiskNumber)
	}
	if m.addduration != nil {
		fields = append(fields, song.FieldDuration)
	}
	if m.addplay_count != nil {
		fields = append(fields, song.FieldPlayCount)
	}
	if m.addskipped_count != nil {
		fields = append(fields, song.FieldSkippedCount)
	}
	if m.addbeats_per_minute != nil {
		fields = append(fields, song.FieldBeatsPerMinute)
	}
	if m.addreplay_gain_album_gain != nil {
		fields = append(fields, song.FieldReplayGainAlbumGain)
	}
	if m.addreplay_gain_album_peak != nil {
		fields = append(fields, song.FieldReplayGainAlbumPeak)
	}
	if m.addreplay_gain_track_gain != nil {
		fields = append(fields, song.FieldReplayGainTrackGain)
	}
	if m.addreplay_gain_track_peak != nil {
		fields = append(fields, song.FieldReplayGainTrackPeak)
	}
	return fields
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *SongMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case song.FieldYear:
		return m.AddedYear()
	case song.FieldTrackNumber:
		return m.AddedTrackNumber()
	case song.FieldOfTrackNumber:
		return m.AddedOfTrackNumber()
	case song.FieldDiskNumber:
		return m.AddedDiskNumber()
	case song.FieldOfDiskNumber:
		return m.AddedOfDiskNumber()
	case song.FieldDuration:
		return m.AddedDuration()
	case song.FieldPlayCount:
		return m.AddedPlayCount()
	case song.FieldSkippedCount:
		return m.AddedSkippedCount()
	case song.FieldBeatsPerMinute:
		return m.AddedBeatsPerMinute()
	case song.FieldReplayGainAlbumGain:
		return m.AddedReplayGainAlbumGain()
	case song.FieldReplayGainAlbumPeak:
		return m.AddedReplayGainAlbumPeak()
	case song.FieldReplayGainTrackGain:
		return m.AddedReplayGainTrackGain()
	case song.FieldReplayGainTrackPeak:
		return m.AddedReplayGainTrackPeak()
	}
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *SongMutation) AddField(name string, value ent.Value) error {
	switch name {
	case song.FieldYear:
		v, ok := value.(uint)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddYear(v)
		return nil
	case song.FieldTrackNumber:
		v, ok := value.(uint)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTrackNumber(v)
		return nil
	case song.FieldOfTrackNumber:
		v, ok := value.(uint)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddOfTrackNumber(v)
		return nil
	case song.FieldDiskNumber:
		v, ok := value.(uint)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDiskNumber(v)
		return nil
	case song.FieldOfDiskNumber:
		v, ok := value.(uint)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddOfDiskNumber(v)
		return nil
	case song.FieldDuration:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDuration(v)
		return nil
	case song.FieldPlayCount:
		v, ok := value.(uint)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPlayCount(v)
		return nil
	case song.FieldSkippedCount:
		v, ok := value.(uint)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSkippedCount(v)
		return nil
	case song.FieldBeatsPerMinute:
		v, ok := value.(uint)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddBeatsPerMinute(v)
		return nil
	case song.FieldReplayGainAlbumGain:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddReplayGainAlbumGain(v)
		return nil
	case song.FieldReplayGainAlbumPeak:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddReplayGainAlbumPeak(v)
		return nil
	case song.FieldReplayGainTrackGain:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddReplayGainTrackGain(v)
		return nil
	case song.FieldReplayGainTrackPeak:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddReplayGainTrackPeak(v)
		return nil
	}
	return fmt.Errorf("unknown Song numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *SongMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(song.FieldTitle) {
		fields = append(fields, song.FieldTitle)
	}
	if m.FieldCleared(song.FieldTitleSort) {
		fields = append(fields, song.FieldTitleSort)
	}
	if m.FieldCleared(song.FieldArtists) {
		fields = append(fields, song.FieldArtists)
	}
	if m.FieldCleared(song.FieldFirstArtist) {
		fields = append(fields, song.FieldFirstArtist)
	}
	if m.FieldCleared(song.FieldFirstArtistSort) {
		fields = append(fields, song.FieldFirstArtistSort)
	}
	if m.FieldCleared(song.FieldFirstAlbumArtist) {
		fields = append(fields, song.FieldFirstAlbumArtist)
	}
	if m.FieldCleared(song.FieldFirstAlbumArtistSort) {
		fields = append(fields, song.FieldFirstAlbumArtistSort)
	}
	if m.FieldCleared(song.FieldAlbumArtist) {
		fields = append(fields, song.FieldAlbumArtist)
	}
	if m.FieldCleared(song.FieldAlbum) {
		fields = append(fields, song.FieldAlbum)
	}
	if m.FieldCleared(song.FieldPublisher) {
		fields = append(fields, song.FieldPublisher)
	}
	if m.FieldCleared(song.FieldFirstComposer) {
		fields = append(fields, song.FieldFirstComposer)
	}
	if m.FieldCleared(song.FieldComposers) {
		fields = append(fields, song.FieldComposers)
	}
	if m.FieldCleared(song.FieldConductor) {
		fields = append(fields, song.FieldConductor)
	}
	if m.FieldCleared(song.FieldGenre) {
		fields = append(fields, song.FieldGenre)
	}
	if m.FieldCleared(song.FieldGrouping) {
		fields = append(fields, song.FieldGrouping)
	}
	if m.FieldCleared(song.FieldYear) {
		fields = append(fields, song.FieldYear)
	}
	if m.FieldCleared(song.FieldTrackNumber) {
		fields = append(fields, song.FieldTrackNumber)
	}
	if m.FieldCleared(song.FieldOfTrackNumber) {
		fields = append(fields, song.FieldOfTrackNumber)
	}
	if m.FieldCleared(song.FieldDiskNumber) {
		fields = append(fields, song.FieldDiskNumber)
	}
	if m.FieldCleared(song.FieldOfDiskNumber) {
		fields = append(fields, song.FieldOfDiskNumber)
	}
	if m.FieldCleared(song.FieldDuration) {
		fields = append(fields, song.FieldDuration)
	}
	if m.FieldCleared(song.FieldComment) {
		fields = append(fields, song.FieldComment)
	}
	if m.FieldCleared(song.FieldBeatsPerMinute) {
		fields = append(fields, song.FieldBeatsPerMinute)
	}
	if m.FieldCleared(song.FieldCopyright) {
		fields = append(fields, song.FieldCopyright)
	}
	if m.FieldCleared(song.FieldDateTagged) {
		fields = append(fields, song.FieldDateTagged)
	}
	if m.FieldCleared(song.FieldDescription) {
		fields = append(fields, song.FieldDescription)
	}
	if m.FieldCleared(song.FieldFirstComposerSort) {
		fields = append(fields, song.FieldFirstComposerSort)
	}
	if m.FieldCleared(song.FieldArtistsSort) {
		fields = append(fields, song.FieldArtistsSort)
	}
	if m.FieldCleared(song.FieldLyrics) {
		fields = append(fields, song.FieldLyrics)
	}
	if m.FieldCleared(song.FieldInitialKey) {
		fields = append(fields, song.FieldInitialKey)
	}
	if m.FieldCleared(song.FieldIsrc) {
		fields = append(fields, song.FieldIsrc)
	}
	if m.FieldCleared(song.FieldSubtitle) {
		fields = append(fields, song.FieldSubtitle)
	}
	if m.FieldCleared(song.FieldMusicBrainzArtistID) {
		fields = append(fields, song.FieldMusicBrainzArtistID)
	}
	if m.FieldCleared(song.FieldMusicBrainzDiscID) {
		fields = append(fields, song.FieldMusicBrainzDiscID)
	}
	if m.FieldCleared(song.FieldMusicBrainzReleaseArtistID) {
		fields = append(fields, song.FieldMusicBrainzReleaseArtistID)
	}
	if m.FieldCleared(song.FieldMusicBrainzReleaseCountry) {
		fields = append(fields, song.FieldMusicBrainzReleaseCountry)
	}
	if m.FieldCleared(song.FieldMusicBrainzReleaseGroupID) {
		fields = append(fields, song.FieldMusicBrainzReleaseGroupID)
	}
	if m.FieldCleared(song.FieldMusicBrainzReleaseID) {
		fields = append(fields, song.FieldMusicBrainzReleaseID)
	}
	if m.FieldCleared(song.FieldMusicBrainzReleaseStatus) {
		fields = append(fields, song.FieldMusicBrainzReleaseStatus)
	}
	if m.FieldCleared(song.FieldMusicBrainzReleaseType) {
		fields = append(fields, song.FieldMusicBrainzReleaseType)
	}
	if m.FieldCleared(song.FieldMusicBrainzTrackID) {
		fields = append(fields, song.FieldMusicBrainzTrackID)
	}
	if m.FieldCleared(song.FieldMusicIPID) {
		fields = append(fields, song.FieldMusicIPID)
	}
	if m.FieldCleared(song.FieldRemixedBy) {
		fields = append(fields, song.FieldRemixedBy)
	}
	if m.FieldCleared(song.FieldReplayGainAlbumGain) {
		fields = append(fields, song.FieldReplayGainAlbumGain)
	}
	if m.FieldCleared(song.FieldReplayGainAlbumPeak) {
		fields = append(fields, song.FieldReplayGainAlbumPeak)
	}
	if m.FieldCleared(song.FieldReplayGainTrackGain) {
		fields = append(fields, song.FieldReplayGainTrackGain)
	}
	if m.FieldCleared(song.FieldReplayGainTrackPeak) {
		fields = append(fields, song.FieldReplayGainTrackPeak)
	}
	if m.FieldCleared(song.FieldMimeType) {
		fields = append(fields, song.FieldMimeType)
	}
	return fields
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *SongMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *SongMutation) ClearField(name string) error {
	switch name {
	case song.FieldTitle:
		m.ClearTitle()
		return nil
	case song.FieldTitleSort:
		m.ClearTitleSort()
		return nil
	case song.FieldArtists:
		m.ClearArtists()
		return nil
	case song.FieldFirstArtist:
		m.ClearFirstArtist()
		return nil
	case song.FieldFirstArtistSort:
		m.ClearFirstArtistSort()
		return nil
	case song.FieldFirstAlbumArtist:
		m.ClearFirstAlbumArtist()
		return nil
	case song.FieldFirstAlbumArtistSort:
		m.ClearFirstAlbumArtistSort()
		return nil
	case song.FieldAlbumArtist:
		m.ClearAlbumArtist()
		return nil
	case song.FieldAlbum:
		m.ClearAlbum()
		return nil
	case song.FieldPublisher:
		m.ClearPublisher()
		return nil
	case song.FieldFirstComposer:
		m.ClearFirstComposer()
		return nil
	case song.FieldComposers:
		m.ClearComposers()
		return nil
	case song.FieldConductor:
		m.ClearConductor()
		return nil
	case song.FieldGenre:
		m.ClearGenre()
		return nil
	case song.FieldGrouping:
		m.ClearGrouping()
		return nil
	case song.FieldYear:
		m.ClearYear()
		return nil
	case song.FieldTrackNumber:
		m.ClearTrackNumber()
		return nil
	case song.FieldOfTrackNumber:
		m.ClearOfTrackNumber()
		return nil
	case song.FieldDiskNumber:
		m.ClearDiskNumber()
		return nil
	case song.FieldOfDiskNumber:
		m.ClearOfDiskNumber()
		return nil
	case song.FieldDuration:
		m.ClearDuration()
		return nil
	case song.FieldComment:
		m.ClearComment()
		return nil
	case song.FieldBeatsPerMinute:
		m.ClearBeatsPerMinute()
		return nil
	case song.FieldCopyright:
		m.ClearCopyright()
		return nil
	case song.FieldDateTagged:
		m.ClearDateTagged()
		return nil
	case song.FieldDescription:
		m.ClearDescription()
		return nil
	case song.FieldFirstComposerSort:
		m.ClearFirstComposerSort()
		return nil
	case song.FieldArtistsSort:
		m.ClearArtistsSort()
		return nil
	case song.FieldLyrics:
		m.ClearLyrics()
		return nil
	case song.FieldInitialKey:
		m.ClearInitialKey()
		return nil
	case song.FieldIsrc:
		m.ClearIsrc()
		return nil
	case song.FieldSubtitle:
		m.ClearSubtitle()
		return nil
	case song.FieldMusicBrainzArtistID:
		m.ClearMusicBrainzArtistID()
		return nil
	case song.FieldMusicBrainzDiscID:
		m.ClearMusicBrainzDiscID()
		return nil
	case song.FieldMusicBrainzReleaseArtistID:
		m.ClearMusicBrainzReleaseArtistID()
		return nil
	case song.FieldMusicBrainzReleaseCountry:
		m.ClearMusicBrainzReleaseCountry()
		return nil
	case song.FieldMusicBrainzReleaseGroupID:
		m.ClearMusicBrainzReleaseGroupID()
		return nil
	case song.FieldMusicBrainzReleaseID:
		m.ClearMusicBrainzReleaseID()
		return nil
	case song.FieldMusicBrainzReleaseStatus:
		m.ClearMusicBrainzReleaseStatus()
		return nil
	case song.FieldMusicBrainzReleaseType:
		m.ClearMusicBrainzReleaseType()
		return nil
	case song.FieldMusicBrainzTrackID:
		m.ClearMusicBrainzTrackID()
		return nil
	case song.FieldMusicIPID:
		m.ClearMusicIPID()
		return nil
	case song.FieldRemixedBy:
		m.ClearRemixedBy()
		return nil
	case song.FieldReplayGainAlbumGain:
		m.ClearReplayGainAlbumGain()
		return nil
	case song.FieldReplayGainAlbumPeak:
		m.ClearReplayGainAlbumPeak()
		return nil
	case song.FieldReplayGainTrackGain:
		m.ClearReplayGainTrackGain()
		return nil
	case song.FieldReplayGainTrackPeak:
		m.ClearReplayGainTrackPeak()
		return nil
	case song.FieldMimeType:
		m.ClearMimeType()
		return nil
	}
	return fmt.Errorf("unknown Song nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *SongMutation) ResetField(name string) error {
	switch name {
	case song.FieldPath:
		m.ResetPath()
		return nil
	case song.FieldTitle:
		m.ResetTitle()
		return nil
	case song.FieldTitleSort:
		m.ResetTitleSort()
		return nil
	case song.FieldArtists:
		m.ResetArtists()
		return nil
	case song.FieldFirstArtist:
		m.ResetFirstArtist()
		return nil
	case song.FieldFirstArtistSort:
		m.ResetFirstArtistSort()
		return nil
	case song.FieldFirstAlbumArtist:
		m.ResetFirstAlbumArtist()
		return nil
	case song.FieldFirstAlbumArtistSort:
		m.ResetFirstAlbumArtistSort()
		return nil
	case song.FieldAlbumArtist:
		m.ResetAlbumArtist()
		return nil
	case song.FieldAlbum:
		m.ResetAlbum()
		return nil
	case song.FieldPublisher:
		m.ResetPublisher()
		return nil
	case song.FieldFirstComposer:
		m.ResetFirstComposer()
		return nil
	case song.FieldComposers:
		m.ResetComposers()
		return nil
	case song.FieldConductor:
		m.ResetConductor()
		return nil
	case song.FieldGenre:
		m.ResetGenre()
		return nil
	case song.FieldGrouping:
		m.ResetGrouping()
		return nil
	case song.FieldYear:
		m.ResetYear()
		return nil
	case song.FieldTrackNumber:
		m.ResetTrackNumber()
		return nil
	case song.FieldOfTrackNumber:
		m.ResetOfTrackNumber()
		return nil
	case song.FieldDiskNumber:
		m.ResetDiskNumber()
		return nil
	case song.FieldOfDiskNumber:
		m.ResetOfDiskNumber()
		return nil
	case song.FieldDuration:
		m.ResetDuration()
		return nil
	case song.FieldPlayCount:
		m.ResetPlayCount()
		return nil
	case song.FieldSkippedCount:
		m.ResetSkippedCount()
		return nil
	case song.FieldComment:
		m.ResetComment()
		return nil
	case song.FieldBeatsPerMinute:
		m.ResetBeatsPerMinute()
		return nil
	case song.FieldCopyright:
		m.ResetCopyright()
		return nil
	case song.FieldDateTagged:
		m.ResetDateTagged()
		return nil
	case song.FieldDescription:
		m.ResetDescription()
		return nil
	case song.FieldFirstComposerSort:
		m.ResetFirstComposerSort()
		return nil
	case song.FieldArtistsSort:
		m.ResetArtistsSort()
		return nil
	case song.FieldLyrics:
		m.ResetLyrics()
		return nil
	case song.FieldInitialKey:
		m.ResetInitialKey()
		return nil
	case song.FieldIsrc:
		m.ResetIsrc()
		return nil
	case song.FieldSubtitle:
		m.ResetSubtitle()
		return nil
	case song.FieldMusicBrainzArtistID:
		m.ResetMusicBrainzArtistID()
		return nil
	case song.FieldMusicBrainzDiscID:
		m.ResetMusicBrainzDiscID()
		return nil
	case song.FieldMusicBrainzReleaseArtistID:
		m.ResetMusicBrainzReleaseArtistID()
		return nil
	case song.FieldMusicBrainzReleaseCountry:
		m.ResetMusicBrainzReleaseCountry()
		return nil
	case song.FieldMusicBrainzReleaseGroupID:
		m.ResetMusicBrainzReleaseGroupID()
		return nil
	case song.FieldMusicBrainzReleaseID:
		m.ResetMusicBrainzReleaseID()
		return nil
	case song.FieldMusicBrainzReleaseStatus:
		m.ResetMusicBrainzReleaseStatus()
		return nil
	case song.FieldMusicBrainzReleaseType:
		m.ResetMusicBrainzReleaseType()
		return nil
	case song.FieldMusicBrainzTrackID:
		m.ResetMusicBrainzTrackID()
		return nil
	case song.FieldMusicIPID:
		m.ResetMusicIPID()
		return nil
	case song.FieldRemixedBy:
		m.ResetRemixedBy()
		return nil
	case song.FieldReplayGainAlbumGain:
		m.ResetReplayGainAlbumGain()
		return nil
	case song.FieldReplayGainAlbumPeak:
		m.ResetReplayGainAlbumPeak()
		return nil
	case song.FieldReplayGainTrackGain:
		m.ResetReplayGainTrackGain()
		return nil
	case song.FieldReplayGainTrackPeak:
		m.ResetReplayGainTrackPeak()
		return nil
	case song.FieldMimeType:
		m.ResetMimeType()
		return nil
	}
	return fmt.Errorf("unknown Song field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *SongMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.tags != nil {
		edges = append(edges, song.EdgeTags)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *SongMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case song.EdgeTags:
		ids := make([]ent.Value, 0, len(m.tags))
		for id := range m.tags {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *SongMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedtags != nil {
		edges = append(edges, song.EdgeTags)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *SongMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case song.EdgeTags:
		ids := make([]ent.Value, 0, len(m.removedtags))
		for id := range m.removedtags {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *SongMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *SongMutation) EdgeCleared(name string) bool {
	switch name {
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *SongMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Song unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *SongMutation) ResetEdge(name string) error {
	switch name {
	case song.EdgeTags:
		m.ResetTags()
		return nil
	}
	return fmt.Errorf("unknown Song edge %s", name)
}

// TagMutation represents an operation that mutate the Tags
// nodes in the graph.
type TagMutation struct {
	config
	op            Op
	typ           string
	id            *int64
	name          *string
	clearedFields map[string]struct{}
	songs         map[int64]struct{}
	removedsongs  map[int64]struct{}
	done          bool
	oldValue      func(context.Context) (*Tag, error)
}

var _ ent.Mutation = (*TagMutation)(nil)

// tagOption allows to manage the mutation configuration using functional options.
type tagOption func(*TagMutation)

// newTagMutation creates new mutation for $n.Name.
func newTagMutation(c config, op Op, opts ...tagOption) *TagMutation {
	m := &TagMutation{
		config:        c,
		op:            op,
		typ:           TypeTag,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTagID sets the id field of the mutation.
func withTagID(id int64) tagOption {
	return func(m *TagMutation) {
		var (
			err   error
			once  sync.Once
			value *Tag
		)
		m.oldValue = func(ctx context.Context) (*Tag, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Tag.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTag sets the old Tag of the mutation.
func withTag(node *Tag) tagOption {
	return func(m *TagMutation) {
		m.oldValue = func(context.Context) (*Tag, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TagMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TagMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *TagMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetName sets the name field.
func (m *TagMutation) SetName(s string) {
	m.name = &s
}

// Name returns the name value in the mutation.
func (m *TagMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old name value of the Tag.
// If the Tag object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *TagMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName reset all changes of the "name" field.
func (m *TagMutation) ResetName() {
	m.name = nil
}

// AddSongIDs adds the songs edge to Song by ids.
func (m *TagMutation) AddSongIDs(ids ...int64) {
	if m.songs == nil {
		m.songs = make(map[int64]struct{})
	}
	for i := range ids {
		m.songs[ids[i]] = struct{}{}
	}
}

// RemoveSongIDs removes the songs edge to Song by ids.
func (m *TagMutation) RemoveSongIDs(ids ...int64) {
	if m.removedsongs == nil {
		m.removedsongs = make(map[int64]struct{})
	}
	for i := range ids {
		m.removedsongs[ids[i]] = struct{}{}
	}
}

// RemovedSongs returns the removed ids of songs.
func (m *TagMutation) RemovedSongsIDs() (ids []int64) {
	for id := range m.removedsongs {
		ids = append(ids, id)
	}
	return
}

// SongsIDs returns the songs ids in the mutation.
func (m *TagMutation) SongsIDs() (ids []int64) {
	for id := range m.songs {
		ids = append(ids, id)
	}
	return
}

// ResetSongs reset all changes of the "songs" edge.
func (m *TagMutation) ResetSongs() {
	m.songs = nil
	m.removedsongs = nil
}

// Op returns the operation name.
func (m *TagMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Tag).
func (m *TagMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *TagMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.name != nil {
		fields = append(fields, tag.FieldName)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *TagMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case tag.FieldName:
		return m.Name()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *TagMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case tag.FieldName:
		return m.OldName(ctx)
	}
	return nil, fmt.Errorf("unknown Tag field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *TagMutation) SetField(name string, value ent.Value) error {
	switch name {
	case tag.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	}
	return fmt.Errorf("unknown Tag field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *TagMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *TagMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *TagMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Tag numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *TagMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *TagMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *TagMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Tag nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *TagMutation) ResetField(name string) error {
	switch name {
	case tag.FieldName:
		m.ResetName()
		return nil
	}
	return fmt.Errorf("unknown Tag field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *TagMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.songs != nil {
		edges = append(edges, tag.EdgeSongs)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *TagMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case tag.EdgeSongs:
		ids := make([]ent.Value, 0, len(m.songs))
		for id := range m.songs {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *TagMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedsongs != nil {
		edges = append(edges, tag.EdgeSongs)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *TagMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case tag.EdgeSongs:
		ids := make([]ent.Value, 0, len(m.removedsongs))
		for id := range m.removedsongs {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *TagMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *TagMutation) EdgeCleared(name string) bool {
	switch name {
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *TagMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Tag unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *TagMutation) ResetEdge(name string) error {
	switch name {
	case tag.EdgeSongs:
		m.ResetSongs()
		return nil
	}
	return fmt.Errorf("unknown Tag edge %s", name)
}
